/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem1. Texture Analysis and Classification
 *
 * Main function:
 * p1_main.cpp
 *
 * Class EdgeDetector:
 * classifier.h
 * classifier.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 */

#include "classifier.h"


Classifier::Classifier(vector <string> new_list_filename_train, vector <string> new_list_label_train,
        vector <string> new_list_filename_test, vector <string> new_list_label_test) {
    // Create Laws' Filter
    int coef_laws_filter[5][5] = {{1, 4, 6, 4, 1}, {-1, -2, 0, 2, 1}, {-1, 0, 2, 0, -1},
                                  {-1, 2, 0, -2, 1}, {1, -4, 6, -4, 1}};
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 5; j++) {
            for (int m = 0; m < 5; m++) {
                for (int n = 0; n < 5; n++) {
                    filter_bank[i * 5 + j][m * 5 + n] = coef_laws_filter[i][m] * coef_laws_filter[j][n];
                }
            }
        }
    }
    // Save testing and training files and labels
    list_filename_train = new_list_filename_train;
    list_filename_test = new_list_filename_test;
    list_label_train = new_list_label_train;
    list_label_test = new_list_label_test;
    num_train = (int)list_filename_train.size();
    num_test = (int)list_filename_test.size();
    // Calculate the number of different labels in the training data
    // Labels must be continuous
    string temp_label = list_label_train[0];
    int temp_num_per_label = 1;
    list_label_name.push_back(temp_label);
    for (int i = 1; i < num_train; i++) {
        if (list_label_train[i] != temp_label) {
            temp_label = list_label_train[i];
            list_label_name.push_back(temp_label);
            list_num_per_label.push_back(temp_num_per_label);
            temp_num_per_label = 0;
        }
        temp_num_per_label++;
    }
    list_num_per_label.push_back(temp_num_per_label);
    num_label = (int)list_num_per_label.size();
}

double *Classifier::Extract_Feature (Img *pt_img, int height, int width, int byteperpixel) {
    // 1. Set original image
    int img[128 * 128];
    for (int i = 0; i < 128; i++) {
        for (int j = 0; j < 128; j++) {
            img[i * 128 + j] = (int)*pt_img++;
        }
    }
    // 2. Subtract local mean from original image
    int img_mean[128 * 128];
    int img_subtract[128 * 128];
    for (int i = 0; i < 128; i++) {
        for (int j = 0; j < 128; j++) {
            int temp_num = 0;
            double temp_total = 0;
            int *window = ImgMatOperator::Get_Window(i , j, 128, 128, 2);
            for (int m = window[0]; m <= window[1]; m++) {
                for (int n = window[2]; n <= window[3]; n++) {
                    temp_total += img[m * 128 + n];
                    temp_num++;
                }
            }
            //img_mean[i * 128 + j] = round(temp_total/temp_num);
            img_subtract[i * 128 + j] = img[i * 128 + j] - round(temp_total/temp_num);
        }
    }
    // 3. Apply Laws' filter to subtracted image and get the average of energy of each pixel
    double img_energy[25][128 * 128];
    double pixel_num = 128 * 128;
    double pixel_total[25];
    for (int k = 0; k < 25; k++) {
        pixel_total[k] = 0;
        for (int i = 0; i < 128; i++) {
            for (int j = 0; j < 128; j++) {
                int temp_num = 0;
                double temp_total = 0;
                int *window = ImgMatOperator::Get_Window(i , j, 128, 128, 2);
                for (int m = window[0]; m <= window[1]; m++) {
                    for (int n = window[2]; n <= window[3]; n++) {
                        temp_total += img_subtract[m * 128 + n] * filter_bank[k][5 * (2 + m - i) + (2 + n - j)];
                        temp_num ++;
                    }
                }
                img_energy[k][128 * i + j] = (temp_total / temp_num) * (temp_total / temp_num);
                pixel_total[k] += img_energy[k][128 * i + j];
            }
        }
        pixel_total[k] = pixel_total[k] / pixel_num;
    }
    // 4. Normalization X' = (X - Xmin) / (Xmax - Xmin)
    /*double pixel_min = pixel_total[0];
    double pixel_max = pixel_total[0];
    for (int i = 1; i < 25; i++) {
        if (pixel_total[i] < pixel_min) {
            pixel_min = pixel_total[i];
        }
        if (pixel_total[i] > pixel_max) {
            pixel_max = pixel_total[i];
        }
    }
    for (int i = 0; i < 25; i++) {
        pixel_total[i] = (pixel_total[i] - pixel_min) / (pixel_max - pixel_min);
    }*/
    double *res = pixel_total;
    return res;
}

void Classifier::Set_Feature () {
    cout << "Set_Feature_Train: " << num_train << endl;
    // For training data
    int count_train = 0;
    for (int i = 0; i < num_label; i++) {
        for (int j = 0; j < list_num_per_label[i]; j++) {
            Img *temp_img = ImgMatOperator::Img_Raw_Read(list_filename_train[count_train++], HEIGHT, WIDTH, BYTEPERPIXEL);
            double *temp_feature = Extract_Feature(temp_img, HEIGHT, WIDTH, BYTEPERPIXEL);
            Mat temp_mat = Mat(1, NUM_DATA, CV_64F, temp_feature).clone();
            mat_feature.push_back(temp_mat);
        }
    }

    // Normalization
    double temp_max[NUM_DATA] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
    double temp_min[NUM_DATA] = {100000, 100000, 100000, 100000, 100000,
                                 100000, 100000, 100000, 100000, 100000,
                                 100000, 100000, 100000, 100000, 100000,
                                 100000, 100000, 100000, 100000, 100000,
                                 100000, 100000, 100000, 100000, 100000};
    for (int i = 0; i < num_train; i++) {
        for (int j = 0; j < NUM_DATA; j++) {
            if (temp_max[j] < mat_feature[i].at<double>(j))
                temp_max[j] = mat_feature[i].at<double>(j);
            if (temp_min[j] > mat_feature[i].at<double>(j))
                temp_min[j] = mat_feature[i].at<double>(j);
        }
    }
    for (int i = 0; i < num_train; i++) {
        for (int j = 0; j < NUM_DATA; j++)
            mat_feature[i].at<double>(j) = (mat_feature[i].at<double>(j) - temp_min[j]) / (temp_max[j] - temp_min[j]);
    }
    int count = 0;
    for (int i = 0; i < num_label; i++) {
        Mat temp_feature_average = Mat::zeros(1, NUM_DATA, CV_64F);
        for (int j = 0; j < list_num_per_label[i]; j++) {
            temp_feature_average += mat_feature[count++];
        }
        mat_feature_average.push_back(temp_feature_average / list_num_per_label[i]);
    }

    // Set a big matrix for later use (PCA, LDA)
    mat_feature_pca_lda = mat_feature[0];
    for (int i = 1; i < num_train; i++) {
        vconcat(mat_feature_pca_lda, mat_feature[i], mat_feature_pca_lda);
    }

    cout << "Set_Feature_Train: " << num_test << endl;
    // For testing data
    for (int i = 0; i < num_test; i++) {
        Img *temp_img = ImgMatOperator::Img_Raw_Read(list_filename_test[i], HEIGHT, WIDTH, BYTEPERPIXEL);
        double *temp_feature = Extract_Feature(temp_img, HEIGHT, WIDTH, BYTEPERPIXEL);
        Mat temp_mat = Mat(1, NUM_DATA, CV_64F, temp_feature).clone();
        for (int j = 0; j < NUM_DATA; j++) {
            temp_mat.at<double>(j) = (temp_mat.at<double>(j) - temp_min[j]) / (temp_max[j] - temp_min[j]);
        }
        mat_feature.push_back(temp_mat);
    }
}

int Classifier::Get_Minimum_Mean_Distance (int num, string label, int mode) {
    Mat temp_covar, temp_covar_invert;
    vector<double> distance;
    double min_distance = 100;
    string min_label = "";
    if (mode == MODE_MM) {
        for (int i = 0; i < num_label; i++) {
            calcCovarMatrix(mat_feature[num], temp_covar, mat_feature_average[i],
                            CV_COVAR_NORMAL|CV_COVAR_ROWS|CV_COVAR_USE_AVG);
            invert(temp_covar, temp_covar_invert, DECOMP_SVD);
            distance.push_back(Mahalanobis(mat_feature[num], mat_feature_average[i], temp_covar));
        }
    } else if (mode == MODE_PCA) {
        for (int i = 0; i < num_label; i++) {
            calcCovarMatrix(mat_feature_pca[num], temp_covar, mat_feature_average_pca[i],
                            CV_COVAR_NORMAL|CV_COVAR_ROWS|CV_COVAR_USE_AVG);
            invert(temp_covar, temp_covar_invert, DECOMP_SVD);
            distance.push_back(Mahalanobis(mat_feature_pca[num], mat_feature_average_pca[i], temp_covar));
        }
    } else {
        for (int i = 0; i < num_label; i++) {
            calcCovarMatrix(mat_feature_lda[num], temp_covar, mat_feature_average_lda[i],
                            CV_COVAR_NORMAL|CV_COVAR_ROWS|CV_COVAR_USE_AVG);
            invert(temp_covar, temp_covar_invert, DECOMP_SVD);
            distance.push_back(Mahalanobis(mat_feature_lda[num], mat_feature_average_lda[i], temp_covar));
        }
    }
    //cout << "N0. " << num << "\t  Distance: ";
    for (int i = 0; i < num_label; i++) {
        //cout << distance[i] << "  ";
        if (min_distance > distance[i]) {
            min_distance = distance[i];
            min_label = list_label_name[i];
        }
    }
    //cout << "   label: " << min_label << "   true_label: " << label << endl;
    // Print result details
    if (num < num_train) {
        if (min_label != label) {
            //cout << label << " " << list_filename_train[num] << " " << num << ": " << min_label << " (*)" << endl;
            return 1;
        }
        else  {
            //cout << label << " " << list_filename_train[num] << " " << num << ": " << min_label << endl;
            return 0;
        }
    } else {
        if (min_label != label) {
            //cout << label << " " << list_filename_test[num - num_train] << " " << num << ": " << min_label << " (*)" << endl;
            return 1;
        }
        else  {
            //cout << label << " " << list_filename_test[num - num_train] << " " << num << ": " << min_label << endl;
            return 0;
        }
    }
}

void Classifier::Classify_MM(int mode, int num) {
    cout << endl << "Classify_MM  Mode: " << mode << " num: " << num << endl;
    if (mode == MODE_PCA && num > 0 && num < 25) {
        Decrease_Dimension_PCA(num);
    } else if (mode == MODE_LDA && num > 0 && num < 25){
        Decrease_Dimension_LDA(num);
    }
    count_error_train = 0;
    count_error_test = 0;
    int count = 0;
    // Read Extracted Feature for training data
    for (int i = 0; i < num_label; i++) {
        for (int k = 0; k < list_num_per_label[i]; k++) {
            count_error_train += Get_Minimum_Mean_Distance (count++, list_label_name[i], mode);
        }
    }
    // Read Extracted Feature for testing data
    for (int k = 0; k < num_test; k++) {
        count_error_test += Get_Minimum_Mean_Distance (count++, list_label_test[k], mode);
    }
}

void Classifier::Decrease_Dimension_PCA(int num) {
    cout << "Decrease_Dimension_PCA" << endl;
    // Get training data set (num-dimension)
    PCA pca = PCA (mat_feature_pca_lda, Mat(), CV_PCA_DATA_AS_ROW, num);
    Mat mat_projected = Mat(num_train, num, CV_64F).clone();
    pca.project(mat_feature_pca_lda, mat_projected);
    for (int i = 0; i < num_train; i++) {
        Mat mat_temp;
        mat_projected.row(i).copyTo(mat_temp);
        mat_feature_pca.push_back(mat_temp);
    }
    // Get testing data set (num-dimension)
    for (int i = 0; i < num_test; i++) {
        mat_projected = pca.project(mat_feature[num_train + i]);
        mat_feature_pca.push_back(mat_projected);
    }
    // Get 2 classes num-dismension mean matrix
    vector<Mat> mat_temp;
    int count = 0;
    for (int i = 0; i < num_label; i++) {
        Mat temp_average;
        mat_temp.push_back(mat_feature_pca[0]);
        for (int j = 0; j < list_num_per_label[i]; j++) {
            vconcat(mat_temp[i], mat_feature_pca[count++], mat_temp[i]);
        }
        reduce(mat_temp[i], temp_average, 0, CV_REDUCE_AVG);
        mat_feature_average_pca.push_back(temp_average);
    }
}

void Classifier::Decrease_Dimension_LDA(int num) {
    cout << "Decrease_Dimension_LDA" << endl;
    //Convert Label
    Mat list_label_known;
    const int NUM_TRAIN = num_train;
    const int NUM_LABEL = num_label;
    int list_label[NUM_TRAIN];
    int count = 0;
    for (int i = 0; i < num_label; i++) {
        for (int j = 0; j < list_num_per_label[i]; j++) {
            list_label[count++] = i;
        }
    }
    list_label_known = Mat(1, num_train, CV_32S, list_label).clone();

    // Get training data set (num-dimension)
    LDA lda = LDA (mat_feature_pca_lda, list_label_known, num);
    Mat mat_projected = Mat(num_train, num, CV_64F).clone();
    mat_projected = lda.project(mat_feature_pca_lda);
    for (int i = 0; i < num_train; i++) {
        Mat mat_temp;
        mat_projected.row(i).copyTo(mat_temp);
        mat_feature_lda.push_back(mat_temp);
    }

    // Get testing data set (num-dimension)
    for (int i = 0; i < num_test; i++) {
        mat_projected = lda.project(mat_feature[num_train + i]);
        mat_feature_lda.push_back(mat_projected);
    }

    // Get 2 classes num-dismension mean matrix
    vector<Mat> mat_temp;
    count = 0;
    for (int i = 0; i < num_label; i++) {
        Mat temp_average;
        mat_temp.push_back(mat_feature_lda[0]);
        for (int j = 0; j < list_num_per_label[i]; j++) {
            vconcat(mat_temp[i], mat_feature_lda[count++], mat_temp[i]);
        }
        reduce(mat_temp[i], temp_average, 0, CV_REDUCE_AVG);
        mat_feature_average_lda.push_back(temp_average);
    }
}

void Classifier::Classify_SVM(int mode, int num) {
    cout << endl << "Classify_SVM  Mode: " << mode << " num: " << num << endl;
    if (mode == MODE_PCA && num > 0 && num < 25) {
        Decrease_Dimension_PCA(num);
    }
    // SVM
    // Label
    const int NUM_TRAIN = num_train;
    const int NUM_TEST = num_test;
    int list_label[NUM_TRAIN];
    for (int i = 0; i < num_train; i++) {
        if (i < list_num_per_label[0])
            list_label[i] = 1;
        else
            list_label[i] = -1;
    }
    int list_label_test_temp[NUM_TEST];
    for (int i = 0; i < num_test; i++) {
        if (i < 12)
            list_label_test_temp[i] = 1;
        else
            list_label_test_temp[i] = -1;
    }
    Mat labelsMat = Mat(num_train, 1, CV_32SC1, list_label).clone();
    // Scaling!!!!
    Mat mat_mean = Mat::zeros(1, num, CV_32F);
    for (int i = 0; i < num; i++) {
        for (int j = 0; j < mat_feature_average_pca.size(); j++) {
            mat_mean.at<float>(0, i) += mat_feature_average_pca[j].at<double>(0, i) * list_num_per_label[j] / num_train;
        }
    }
    const int NUM = num;
    float scale[NUM];
    for (int i = 0; i < num; i++) {
        float total = 0;
        for (int j = 0; j < num_train; j++) {
            float value = mat_feature_pca[j].at<double>(0, i);
            total += (value - mat_mean.at<float>(0, i)) * (value - mat_mean.at<float>(0, i)) / (num_train - 1);
        }
        scale[i] = sqrt(total);
        //cout << "scale: " << scale[1] << endl;
    }
    // Set Training data
    Mat mat_train = Mat(num_train, num, CV_32F).clone();
    for (int i = 0; i < num_train; i++) {
        for (int j = 0; j < num; j++) {
            float value = (float)mat_feature_pca[i].at<double>(0, j) / scale[j] ;
            mat_train.at<float>(i, j) = value;
        }
    }
    // SVM train
    Ptr<SVM> svm = SVM::create();
    svm->setType(SVM::C_SVC);
    svm->setKernel(SVM::LINEAR);
    svm->setTermCriteria(TermCriteria(TermCriteria::MAX_ITER, 100, 1e-6));
    svm->train(mat_train, ROW_SAMPLE, labelsMat);
    // SVM predict
    vector<float> res;
    Mat mat_test = Mat(1, num, CV_32F);
    for (int i = 0; i < num_test + num_train; i++) {
        for (int j = 0; j < num; j++) {
            float value = (float)mat_feature_pca[i].at<double>(0, j) / scale[j];
            mat_test.at<float>(0, j) = value;
        }
        res.push_back(svm->predict(mat_test));
    }
    // Get error rate
    count_error_train = 0;
    count_error_test = 0;
    for (int i = 0; i < num_train; i++) {
        if (res[i] != list_label[i]) {
            //cout << "No" << i << ": " << list_label[i] << "  " << res[i] << "  (*)" << endl;
            count_error_train++;
        } else {
            //cout << "No" << i << ": " << list_label[i] << "  " << res[i] << endl;
        }
    }
    for (int i = 0; i < num_test; i++) {
        if (res[i + num_train] != list_label_test_temp[i]) {
            //cout << "No" << i + num_train << ": " << list_label_test_temp[i] << "  " << res[i + num_train] << "  (*)" << endl;
            count_error_test++;
        } else {
            //cout << "No" << i + num_train << ": " << list_label_test_temp[i] << "  " << res[i + num_train] << endl;
        }
    }
}

void Classifier::Print_Label() {
    cout << "num_train: " << num_train << " num_test: " << num_test << endl;
    for (int i = 0; i < num_train; i++) {
        cout << "list_train: " << list_label_train[i] << "  " << list_filename_train[i] << endl;
    }
    cout << endl;
    for (int i = 0; i < num_test; i++) {
        cout << "list_test: " << list_label_test[i] << "  " << list_filename_test[i] << endl;
    }
    cout << endl << "num_label: " << num_label << endl;
    for (int i = 0; i < num_label; i++) {
        cout << "label name: " << list_label_name[i] << " label num: " << list_num_per_label[i] << endl;
    }
    cout << endl;
}

void Classifier::Print_Error_Rate() {
    cout << "error_rate_total: " << 100 * (double)(count_error_train + count_error_test) / (double)(num_train + num_test) << " %" << endl;
    cout << "error_rate_train: " << 100 * (double)count_error_train / (double)num_train << " %" << endl;
    cout << "error_rate_test: " << 100 * (double)count_error_test / (double)num_test << " %" << endl;
}

void Classifier::Print_Stat(int mode) {
    if (mode == 0) {
        //cout << "----------mat_feature----------" << endl;
        for (int i = 0; i < mat_feature.size(); i++) {
            //cout << mat_feature[i] << endl;
        }
        cout << "----------mat_feature_average----------" << endl;
        for (int i = 0; i < mat_feature_average.size(); i++) {
            Mat temp;
            transpose(mat_feature_average[i], temp);
            cout << temp << endl;
        }
    } else if (mode == 1) {
        //cout << "----------mat_feature_pca----------" << endl;
        for (int i = 0; i < mat_feature_pca.size(); i++) {
            //cout << mat_feature_pca[i] << endl;
        }
        cout << "----------mat_feature_average_pca----------" << endl;
        for (int i = 0; i < mat_feature_average_pca.size(); i++) {
            Mat temp;
            transpose(mat_feature_average_pca[i], temp);
            cout << temp << endl;
        }
    } else if (mode == 2) {
        //cout << "----------mat_feature_lda----------" << endl;
        for (int i = 0; i < mat_feature_lda.size(); i++) {
            //cout << mat_feature_lda[i] << endl;
        }
        cout << "----------mat_feature_average_lda----------" << endl;
        for (int i = 0; i < mat_feature_average_lda.size(); i++) {
            Mat temp;
            transpose(mat_feature_average_lda[i], temp);
            cout << temp << endl;
        }
    } else {
        cout << "ERROR" << endl << endl;
    }
}



/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem1. Texture Analysis and Classification
 *
 * Main function:
 * p1_main.cpp
 *
 * Class EdgeDetector:
 * classifier.h
 * classifier.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 */

#ifndef CLASSIFIER_H
#define CLASSIFIER_H

#include "hw2_helper.h"
#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>
#include "opencv2/imgcodecs.hpp"
#include <opencv2/highgui.hpp>
#include <opencv2/ml.hpp>

using namespace cv;
using namespace cv::ml;


// Declaration of default parameter
// Image
const int HEIGHT = 128;
const int WIDTH = 128;
const int BYTEPERPIXEL = 1;
// Law's filter
const int NUM_DATA = 25;
// Mode
const int MODE_MM = 0;
const int MODE_PCA = 1;
const int MODE_LDA = 2;


class Classifier {
private:
    // 25 5 * 5 Law's Filter
    int filter_bank[25][25];

    // input training and testing data
    vector <string> list_filename_train;
    vector <string> list_label_train;
    vector <string> list_filename_test;
    vector <string> list_label_test;
    int num_test;
    int num_train;
    int num_label;
    vector <string> list_label_name;
    vector <int> list_num_per_label;

    // extract feature
    vector <Mat> mat_feature;
    vector <Mat> mat_feature_average;
    Mat mat_feature_pca_lda;
    vector <Mat> mat_feature_average_pca;
    vector <Mat> mat_feature_pca;
    vector <Mat> mat_feature_average_lda;
    vector <Mat> mat_feature_lda;

    // error rate
    int count_error_train;
    int count_error_test;

    // functions
    double *Extract_Feature (Img*, int, int, int);
    void Decrease_Dimension_PCA(int);
    void Decrease_Dimension_LDA(int);
    int Get_Minimum_Mean_Distance (int, string, int);

public:
    Classifier(vector<string>, vector<string>, vector<string>, vector<string>);
    void Set_Feature();
    void Classify_MM(int mode, int num);
    void Classify_SVM(int mode, int num);

    void Print_Error_Rate();
    void Print_Stat(int);
    void Print_Label();
};

#endif //P1_CLASSIFER_H



/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem1. Texture Analysis and Classification
 *
 * Main function:
 * p1_main.cpp
 *
 * Class EdgeDetector:
 * classifier.h
 * classifier.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 */


#include "hw2_helper.h"

ImgMatOperator::ImgMatOperator()
{

}

Img* ImgMatOperator::Img_Raw_Read (char *filename, int height, int width, int byteperpixel)
{
    // cout << "Img_Raw_Read: " << filename << endl;
    FILE *file;
    if (!(file = fopen(filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);
    Img *pt_image = image;
    return pt_image;
}

Img* ImgMatOperator::Img_Raw_Read (string filename, int height, int width, int byteperpixel)
{
    // cout << "Img_Raw_Read: " << filename << endl;
    char *c_filename = new char[filename.length() + 1];
    strcpy(c_filename, filename.c_str());
    FILE *file;
    if (!(file = fopen(c_filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);
    Img *pt_image = image;
    return pt_image;
}

void ImgMatOperator::Img_Raw_Write (char* filename, Img *pt_image, int height, int width, int byteperpixel)
{
    cout << "Img_Raw_Write: " << filename << endl;
    FILE *file;
    if (!(file = fopen(filename, "wb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    memcpy(image, pt_image, size);
    fwrite(image, sizeof(Img), size, file);
    fclose(file);
}

void ImgMatOperator::Mat_File_Print (Mat mat, string filename)
{
    cout << "Mat_File_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    fout << mat << endl;
    fout.close();
}

void ImgMatOperator::Img_File_Print (Img *image, string filename, int height, int width, int byteperpixel)
{
    cout << "Img_File_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            for (int k = 0; k < byteperpixel; k++)
                fout << (int)*image++ << " ";
        }
        fout << endl;
    }
    fout.close();
}

void ImgMatOperator::Mat_XML_Print(Mat mat, string filename)
{
    cout << "Mat_XML_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    for (int i = 0; i < mat.rows; i++)
    {
        for (int j = 0; j < mat.cols; j++)
            fout << (int)mat.data[i * mat.cols + j] << endl;
    }
    fout.close();
}

Mat ImgMatOperator::Img_To_Mat_Convert (Img *image, int height, int width, int byteperpixel)
{
    cout << "Img_To_Mat_Convert" << endl;
    Mat mat(height, width, CV_8UC1, image);
    return mat;
}

void ImgMatOperator::Mat_Raw_Write (Mat mat, string filename)
{
    cout << "Mat_Raw_Write_Gray: " << filename << endl;
    Img image[128 * 128];
    fstream fout;

    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << "testxx.raw" << endl;
    }

    for (int i = 0; i < 128 * 128; i++)
    {
        fout << (Img)mat.data[i];
    }
    fout.close();

}

Mat ImgMatOperator::Mat_Raw_Read (string filename, int height, int width, int byteperpixel)
{
    //cout << "Mat_Raw_Read: " << filename << endl;
    char *c_filename = new char[filename.length() + 1];
    strcpy(c_filename, filename.c_str());

    Img *img = new Img[128 * 128];
    Img *pt_img = Img_Raw_Read(c_filename, 128, 128, 1);

    for (int i = 0; i < 128 * 128; i++)
        img[i] = *pt_img++;

    Mat mat = Mat(128, 128, CV_8UC1, img).clone();
    return mat;
}

int *ImgMatOperator::Get_Window(int i, int j, int height, int width, int half_window) {
    // top, bottom, left, right
    int window[4] = {i - half_window, i + half_window, j - half_window, j + 2};
    if (window[0] < 0)
        window[0] = 0;
    if (window[2] < 0)
        window[2] = 0;
    if (window[1] > height - 1)
        window[1] = height - 1;
    if (window[3] > width - 1)
        window[3] = width - 1;
    int *res = window;
    return res;
}

void ImgMatOperator::Test()
{
    cout << "Test" << endl;
    char filename[] = "p1_image/p1_image_a/grass_01.raw";
    Img *pt_image = Img_Raw_Read(filename, 128, 128, 1);
    Img image[128 * 128];
    for (int i = 0; i < 128 * 128 * 1; i++)
        image[i] = pt_image[i];
    strcpy(filename, "test_img_raw_write.raw");
    Img_Raw_Write(filename, image, 128, 128, 1);
    Img_File_Print(image, "test_img_file_print.txt", 128, 128, 1);
    Mat mat = Img_To_Mat_Convert(image, 128, 128, 1);
    Mat_File_Print(mat, "test_mat_file_print.txt");
    Mat_Raw_Write(mat, "test_mat_raw_write.raw");
    Mat_XML_Print(mat, "test_mat_xml_print.txt");

    Mat mat2 = Mat_Raw_Read("p1_image/p1_image_a/grass_01.raw", 128, 128, 1);
    // cout << "MAT2: " << mat2 << endl << endl;
}
/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem1. Texture Analysis and Classification
 *
 * Main function:
 * p1_main.cpp
 *
 * Class EdgeDetector:
 * classifier.h
 * classifier.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 */

#ifndef HW2_HELPER_H
#define HW2_HELPER_H

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h>
#include <fstream>
#include <cstring>
#include <opencv2/opencv.hpp>


typedef unsigned char Img;

using namespace cv;
using namespace std;

class ImgMatOperator {
public:
    ImgMatOperator();

    Img* Img_Raw_Read (char *filename, int height, int width, int byteperpixel);
    static Img* Img_Raw_Read (string, int, int, int);
    void Img_Raw_Write (char* filename, Img *image, int height, int width, int byteperpixel);
    void Img_File_Print (Img *image, string filename, int height, int width, int byteperpixel);
    Mat Img_To_Mat_Convert (Img *image, int height, int width, int byteperpixel);

    void Mat_File_Print (Mat mat, string filename);
    void Mat_XML_Print(Mat mat, string filename);
    void Mat_Raw_Write(Mat mat, string filename);
    Mat Mat_Raw_Read(string filename, int height, int width, int byteperpixel);

    static int *Get_Window(int i, int j, int height, int width, int half_window);
    void Test();
};


#endif //HW2_P1A_H

/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem1. Texture Analysis and Classification
 *
 * Main function:
 * p1_main.cpp
 *
 * Class EdgeDetector:
 * classifier.h
 * classifier.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 */

#include "classifier.h"

// Declaration of default parameter
const string LABEL[5] = {"grass", "straw", "sand", "leather", "unknown"};
const string FOLDER1 = "p1_image/p1_image_a/";
const string FOLDER2 = "p1_image/p1_image_b/";


// Declaration of functions
string Convert_Filename (string, int);
void Get_List_Filename_Label_a (vector<string>*, vector<string>*, vector<string>*, vector<string>*);
void Get_List_Filename_Label_b (vector<string>*, vector<string>*, vector<string>*, vector<string>*, int*);
void Prob1a();
void Prob1b();


// Functions for get filename
string Convert_Filename (string label, int num) {
    string str_num;
    num++;
    if (num < 10)
        str_num = "0" + to_string(num);
    else
        str_num = to_string(num);
    return label + "_" + str_num + ".raw";
}

void Get_List_Filename_Label_a (vector <string> *list_filename_train, vector <string> *list_label_train,
                                    vector <string> *list_filename_test, vector <string> *list_label_test) {
    // Get filename and label list for training set
    for (int i = 0; i < 72; i++) {
        if (i < 36) {
            list_label_train->push_back(LABEL[0]);
            list_filename_train->push_back(FOLDER1 + Convert_Filename(LABEL[0], i));
        }
        else {
            list_label_train->push_back(LABEL[1]);
            list_filename_train->push_back(FOLDER1 + Convert_Filename(LABEL[1], i - 36));
        }
    }
    // Get filename and label list for testing set
    string temp_list_label_test[24] =
            {"straw", "straw", "grass", "grass", "grass", "straw",
             "grass", "straw", "straw", "grass", "grass", "grass",
             "straw", "grass", "straw" , "straw", "straw", "straw",
             "grass", "grass", "grass", "straw", "straw", "grass"};
    for (int i = 0; i < 24; i++)
    {
        list_label_test->push_back(temp_list_label_test[i]);
        list_filename_test->push_back(FOLDER1 + Convert_Filename(LABEL[4], i));
    }
}

void Get_List_Filename_Label_b(vector <string> *list_filename_train, vector <string> *list_label_train,
                                    vector <string> *list_filename_test, vector <string> *list_label_test,
                                    int* pt_index_label) {
    // Clear vector list
    list_filename_train->clear();
    list_filename_test->clear();
    list_label_train->clear();
    list_label_test->clear();
    int index_label[4];
    for (int i = 0; i < 4; i++) {
        index_label[i] = *pt_index_label++;
    }
    // Get filename and label list for training set
    for (int i = 0; i < 36; i++) {
        list_label_train->push_back(LABEL[index_label[0]]);
        list_filename_train->push_back(FOLDER2 + Convert_Filename(LABEL[index_label[0]], i));
    }
    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 12; j++) {
            list_label_train->push_back(LABEL[index_label[i + 1]]);
            list_filename_train->push_back(FOLDER2 + Convert_Filename(LABEL[index_label[i + 1]], j));
        }
    }
    // Get filename and label list for testing set
    string temp_list_label_test[12] = {LABEL[index_label[0]]};
    for (int i = 36; i < 48; i++)
    {
        list_label_test->push_back(LABEL[index_label[0]]);
        list_filename_test->push_back(FOLDER2 + Convert_Filename(LABEL[index_label[0]], i));
    }
    for (int i = 0; i < 3; i++) {
        for (int j = 12; j < 16; j++) {
            list_label_test->push_back(LABEL[index_label[i + 1]]);
            list_filename_test->push_back(FOLDER2 + Convert_Filename(LABEL[index_label[i + 1]], j));
        }
    }
}


// Function to implement problem 1
void Prob1a()
{
    cout << "Problem1a" << endl;
    vector <string> list_filename_train;
    vector <string> list_label_train;
    vector <string> list_filename_test;
    vector <string> list_label_test;
    Get_List_Filename_Label_a(&list_filename_train, &list_label_train, &list_filename_test, &list_label_test);
    Classifier classifier = Classifier(list_filename_train, list_label_train,
                                       list_filename_test, list_label_test);
    // problem1a 1): Feature Extract
    classifier.Set_Feature();
    classifier.Print_Stat(0);

    // problem1a 2): MM
    classifier.Classify_MM(MODE_MM, 0);
    classifier.Print_Error_Rate();

    // problem1a 3 & 5): PCA, dimension = 1
    classifier.Classify_MM(MODE_PCA, 1);
    classifier.Print_Error_Rate();
    classifier.Print_Stat(1);

    // problem1a 3 & 5): PCA, dimension = 2
    classifier.Classify_MM(MODE_PCA, 2);
    classifier.Print_Error_Rate();
    classifier.Print_Stat(1);

    // problem1a 3 & 5): PCA, dimension = 3
    classifier.Classify_MM(MODE_PCA, 3);
    classifier.Print_Error_Rate();
    classifier.Print_Stat(1);

    // problem1a 4 & 5): PCA, dimension = 1
    classifier.Classify_MM(MODE_LDA, 1);
    classifier.Print_Error_Rate();
    classifier.Print_Stat(2);

    // problem1a 4 & 5): PCA, dimension = 2
    classifier.Classify_MM(MODE_LDA, 2);
    classifier.Print_Error_Rate();
    classifier.Print_Stat(2);

    // problem1a 4 & 5): PCA, dimension = 3
    classifier.Classify_MM(MODE_LDA, 3);
    classifier.Print_Error_Rate();
    classifier.Print_Stat(2);
}

void Prob1b() {
    cout << "Problem1b" << endl;
    vector<string> list_filename_train;
    vector<string> list_label_train;
    vector<string> list_filename_test;
    vector<string> list_label_test;
    int index_label[4][4] = {{0, 1, 2, 3},
                             {1, 0, 2, 3},
                             {2, 0, 1, 3},
                             {3, 0, 1, 2}};
    // problem1b 2): Minimum distance (PDA)
    for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_MM(MODE_PCA, 1);
        classifier.Print_Error_Rate();
    }

    // Cases for discussion
    /*for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_MM(MODE_PCA, 2);
        classifier.Print_Error_Rate();
    }
    for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_MM(MODE_PCA, 3);
        classifier.Print_Error_Rate();
    }*/

    // problem1b 2): Minimum distance (LDA)
    for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_MM(MODE_LDA, 1);
        classifier.Print_Error_Rate();
    }

    // Cases for discussion
    /*for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_MM(MODE_LDA, 2);
        classifier.Print_Error_Rate();
    }
    for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_MM(MODE_LDA, 3);
        classifier.Print_Error_Rate();
    }*/

    // Problem1b 3): SVM (PDA)
    for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_SVM(MODE_PCA, 1);
        classifier.Print_Error_Rate();
    }

    // Cases for discussion
    /*for (int i = 0; i < 4; i++) {
        cout << "----------------------" << LABEL[i] << "--------------------" << endl;
        Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                  &list_filename_test, &list_label_test, index_label[i]);
        Classifier classifier = Classifier(list_filename_train, list_label_train,
                                           list_filename_test, list_label_test);
        classifier.Set_Feature();
        classifier.Classify_SVM(MODE_PCA, 2);
        classifier.Print_Error_Rate();
    }*/

    /*for (int i = 0; i < 4; i++) {
       cout << "----------------------" << LABEL[i] << "--------------------" << endl;
       Get_List_Filename_Label_b(&list_filename_train, &list_label_train,
                                 &list_filename_test, &list_label_test, index_label[i]);
       Classifier classifier = Classifier(list_filename_train, list_label_train,
                                          list_filename_test, list_label_test);
       classifier.Set_Feature();
       classifier.Classify_SVM(MODE_PCA, 3);
       classifier.Print_Error_Rate();
   }*/
}

int main(int argc, char *argv[])
{
    cout << "Problem 1" << endl;
    Prob1a();
    Prob1b();
    return 0;
}
/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Edge Detection
 *
 *
 * Main function:
 * p2_main.cpp
 *
 * Class EdgeDetector:
 * edge_detector.h
 * edge_detector.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * p2c: matlab code
 * prob2c.m
 * detector_SE.m
 */

#include "edge_detector.h"

// Constructor
EdgeDetector::EdgeDetector(string filename, int new_height, int new_width, int new_byteperpixel) {
    Mat mat = ImgMatOperator::Mat_Raw_Read(filename, new_height, new_width, new_byteperpixel);
    height = new_height;
    width = new_width;
    byteperpixel = new_byteperpixel;
    mat_original = mat.clone();
}

// p2a & p2b: Convert RGB image to grayscale for Sobel detector / Canny detector
void EdgeDetector::ConvertRGB() {
    Mat mat_color = mat_original.clone();
    if (mat_color.channels() == 3) {
        double img_gray[height * width];
        int count = 0;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++)
                img_gray[count++] = mat_color.at<double>(i, j * 3) * 0.21
                                    + mat_color.at<double>(i, j * 3 + 1) * 0.72
                                    + mat_color.at<double>(i, j * 3 + 2) * 0.07;
        }
        mat_gray = Mat(height, width, CV_64F, img_gray).clone();
    } else
        mat_gray = mat_color.clone();
}

// p2a:Sobel edge detector and non-maximual-suppression
void EdgeDetector::Detector_Sobel(double threshold) {
    // 1. Check parameter
    if (threshold >= 1 || threshold <= 0)
        exit(1);

    // 2. Apply Sobel filter to x, y two dimensions
    // 2.1 Generate Sobel mask
    double filter[2][9] = {{-0.25, 0,    0.25,  -0.5, 0, 0.5, -0.25, 0,   0.25},
                           {-0.25, -0.5, -0.25, 0,    0, 0,   0.25,  0.5, 0.25}};
    Mat mat_gradient_x = Mat(height, width, CV_64F);
    Mat mat_gradient_y = Mat(height, width, CV_64F);
    // 2.2 Apply Sobel mask to x direction, and get gradient x
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            double temp_total = 0;
            int *window = ImgMatOperator::Get_Window(i, j, height, width, 1);
            for (int m = window[0]; m <= window[1]; m++) {
                for (int n = window[2]; n <= window[3]; n++)
                    temp_total += filter[0][3 * (1 + m - i) + (1 + n - j)] * mat_gray.at<double>(m, n);
            }
            mat_gradient_x.at<double>(i, j) = temp_total;
        }
    }
    // 2.3 Apply Sobel mask to y direction, and get gradient y
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            double temp_total = 0;
            int *window = ImgMatOperator::Get_Window(i, j, height, width, 1);
            for (int m = window[0]; m <= window[1]; m++) {
                for (int n = window[2]; n <= window[3]; n++)
                    temp_total += filter[1][3 * (1 + m - i) + (1 + n - j)] * mat_gray.at<double>(m, n);
            }
            mat_gradient_y.at<double>(i, j) = temp_total;
        }
    }
    // 2.4 Get magnitude image gradient_x, gradient_y
    Mat mat_magnitude = Mat(height, width, CV_64F);
    Mat mat_oritentation = Mat(height, width, CV_64F);
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++)
            mat_magnitude.at<double>(i, j) =
                    sqrt(mat_gradient_x.at<double>(i, j) * mat_gradient_x.at<double>(i, j)
                         + mat_gradient_y.at<double>(i, j) * mat_gradient_y.at<double>(i, j));
    }

    // 3. Normalize the magnitude matrix to 0 ~ 255
    double min = 10000, max = -10000;
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            double temp = mat_magnitude.at<double>(i, j);
            if (temp < min)
                min = temp;
            if (temp > max)
                max = temp;
        }
    }
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++)
            mat_magnitude.at<double>(i, j) = (mat_magnitude.at<double>(i, j) - min) * 255.0 / (max - min);
    }

    // 4. Use threshold to binary the edge and non-edge
    // 4.1 Sort the normalized matrix and get the intensity value by threshold
    vector<double> vector_temp;
    Mat mat_threshold = Mat(height, width, CV_64F);
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++)
            vector_temp.push_back(mat_magnitude.at<double>(i, j));
    }
    sort(vector_temp.begin(), vector_temp.end());
    double threshold_value = vector_temp[height * width * (1 - threshold)];
    // 4.2 Set black to edge, white to non-edge in the normalized image
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            if (mat_magnitude.at<double>(i, j) > threshold_value)
                mat_threshold.at<double>(i, j) = 0;
            else
                mat_threshold.at<double>(i, j) = 1;
        }
    }

    // 5. non-maximum suprression
    Mat mat_suppress = Mat::ones(height, width, CV_64F);
    for (int i = 1; i < height - 1; i++) {
        for (int j = 1; j < width - 1; j++) {
            double temp_x = mat_gradient_x.at<double>(i, j);
            double temp_y = mat_gradient_x.at<double>(i, j);
            double temp_value;
            if (temp_x * temp_x >= temp_y * temp_y) {
                temp_value = mat_threshold.at<double>(i, j);
                if (temp_value >= mat_threshold.at<double>(i, j - 1)
                    && temp_value >= mat_threshold.at<double>(i, j + 1))
                    mat_suppress.at<double>(i, j) = 1;
                else
                    mat_suppress.at<double>(i, j) = 0;
            } else {
                temp_value = mat_threshold.at<double>(i, j);
                if (temp_value >= mat_threshold.at<double>(i - 1, j)
                    && temp_value >= mat_threshold.at<double>(i + 1, j))
                    mat_suppress.at<double>(i, j) = 1;
                else
                    mat_suppress.at<double>(i, j) = 0;
            }
        }
    }

    // 6. Print raw image for report
    Print_Raw(mat_original, "Farm_original.raw", 0, 3);
    Print_Raw(mat_gray, "Farm_gary.raw", 0, 1);
    Print_Raw(mat_gradient_x, "Farm_gradient_x.raw", 1, 1);
    Print_Raw(mat_gradient_y, "Farm_gradient_y.raw", 1, 1);
    Print_Raw(mat_magnitude, "Farm_magnitude.raw", 0, 1);
    Print_Raw(mat_threshold, "Farm_threshold_015.raw", 1, 1);
    Print_Raw(mat_suppress, "Farm_suppression_015.raw", 1, 1);
}

// p2b: Canny edge detector
void EdgeDetector::Detector_Canny(double coef_A, double coef_B) {
    // Apply Canny
    Mat mat_canny;
    Mat mat_temp = Mat(height, width, CV_8U);
    mat_gray.convertTo(mat_temp, CV_8U);
    Canny(mat_temp, mat_canny, coef_A * 255, coef_B * 255);

    // Convert the result to print raw image
    mat_canny.convertTo(mat_canny, CV_64F);
    Mat mat_temp2 = Mat::ones(height, width, CV_64F) * 255;
    mat_canny = mat_temp2 - mat_canny;
    string str = "Cougar_" + to_string((int)(10 * coef_A)) + "_" + to_string((int)(10 * coef_B)) + ".raw";
    Print_Raw(mat_canny, str, 0, 1);
}

// p2d: performation evaluation function
void EdgeDetector::Evaluation(string filename_measure, vector<string> filename_gt,
                              int new_height, int new_width, int new_byteperpixel) {
    double measure_p = 0;
    double measure_r = 0;
    int size = filename_gt.size();
    for(int i = 0; i < size; i++) {
        // Get Ground truth image
        Img *pt_img_gt = ImgMatOperator::Img_Raw_Read(filename_gt[i], new_height, new_width, new_byteperpixel);
        Img img_gt[new_height * new_width];
        memcpy(img_gt, pt_img_gt, new_height * new_width);

        // Get evaluation image
        Img *pt_img = ImgMatOperator::Img_Raw_Read(filename_measure, new_height, new_width, new_byteperpixel);
        Img img[new_height * new_width];
        memcpy(img, pt_img, new_height * new_width);

        // Begin to count tp, tn, fp, fn
        double num_tp = 0, num_tn = 0, num_fp = 0, num_fn = 0;
        for(int i = 0; i < new_height * new_width; i++) {
            if (img[i] == 0 && img_gt[i] == 0) {
                num_tp++;
            } else if (img[i] != 0 && img_gt[i] != 0) {
                num_tn++;
            } else if (img[i] == 0 && img_gt[i] != 0) {
                num_fp++;
            } else if (img[i] != 0 && img_gt[i] == 0) {
                num_fn++;
            }
        }
        measure_p += num_tp / (num_tp + num_fp);
        measure_r += num_tp / (num_tp + num_fn);
    }

    // Get mean of five P, R and calcuate F
    measure_p /= size;
    measure_r /= size;
    double measure_f = 2 * measure_p * measure_r / (measure_p + measure_r);

    // Print
    cout << filename_measure << "\t\t";
    cout << "P: " << measure_p * 100 << "%  R: " << measure_r * 100 << "%  F: " << measure_f * 100 << "%" << endl;
}


// Helper function: print the result to report
//@Para mode: 1 normalization; 0 no normalization;
void EdgeDetector::Print_Raw(Mat mat, string filename, int mode, int byte) {
    if (mode == 1) {
        int cols = mat.cols;
        int rows = mat.rows;
        double min = 10000;
        double max = -10000;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                double temp = mat.at<double>(i, j);
                if (temp < min)
                    min = temp;
                if (temp > max)
                    max = temp;
            }
        }
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++)
                mat.at<double>(i, j) = (mat.at<double>(i, j) - min) / (max - min);
        }
        mat = mat * 255.0;
    }
    if (byte == 1)
        ImgMatOperator::Mat_Raw_Write_Gray(mat, filename);
    if (byte == 3) {
        ImgMatOperator::Mat_Raw_Write_Color(mat, filename);
    }


}

/* void EdgeDetector::Print_Mat(Mat mat, string name) {
    int cols = mat.cols;
    int rows = mat.rows;
    double min = 10000;
    double max = -10000;
    cout << name << ": " << endl;
    for (int i = 0; i < 20; i++) {
        for (int j = 0; j < 20; j++) {
            cout << mat.at<double>(i, j) << ", ";
        }
        cout << endl;
    }
    cout << endl;
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            double temp = mat.at<double>(i, j);
            if (temp < min) {
                min = temp;
            }
            if (temp > max) {
                max = temp;
            }
        }
    }
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            mat.at<double>(i, j) = (mat.at<double>(i, j) - min) / (max - min);
        }
    }
    imshow(name, mat);
    waitKey(0);
}

void EdgeDetector::Print_Detail() {
    cout << "Print_Detail" << endl;
    cout << "height: " << height << " width: " << width << " byteperpixel: " << byteperpixel << endl;

    imshow("mat_original", mat_original / 255.0);
    cout << "mat_original: " << endl;
    for (int i = 0; i < 10; i++) {
        cout << mat_original.at<double>(height - 1, i) << ", ";
    }
    cout << endl;
    waitKey(0);

    imshow("mat_gray", mat_gray / 255.0);
    cout << "mat_gray: " << endl;
    for (int i = 0; i < 10; i++) {
        cout << mat_gray.at<double>(height - 1, i) << ", ";
    }
    cout << endl;
    waitKey(0);
}*/

/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Edge Detection
 *
 *
 * Main function:
 * p2_main.cpp
 *
 * Class EdgeDetector:
 * edge_detector.h
 * edge_detector.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * p2c: matlab code
 * prob2c.m
 * detector_SE.m
 */

#ifndef P2_EDGE_DETECTOR_H
#define P2_EDGE_DETECTOR_H

#include "hw2_helper.h"
using namespace std;
using namespace cv;

class EdgeDetector {
private:
    int height;
    int width;
    int byteperpixel;
    Mat mat_gray;
    Mat mat_original;

public:
    // construction;
    EdgeDetector(string filename, int new_height, int new_width, int new_byteperpixel);
    //EdgeDetector(Mat mat, int new_height, int new_width, int new_byteperpixel);
    //EdgeDetector(Img *pt_img, int new_height, int new_width, int new_byteperpixel);

    void ConvertRGB();
    void Detector_Sobel(double threshold);
    void Detector_Canny(double coef_A, double coef_B);

    static void Evaluation(string filename_measure, vector<string> filename_gt, int, int, int);

    // Helper function
    // mode: 1 normalization; 0 no normalization;
    void Print_Raw(Mat mat, string filename, int mode, int byte);
    //void Print_Mat(Mat mat, string name);
    //void Print_Detail();
};
#endif //P2_EDGE_DETECTOR_H
/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Edge Detection
 *
 *
 * Main function:
 * p2_main.cpp
 *
 * Class EdgeDetector:
 * edge_detector.h
 * edge_detector.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * p2c: matlab code
 * prob2c.m
 * detector_SE.m
 */

#include "hw2_helper.h"

ImgMatOperator::ImgMatOperator()
{

}

Img* ImgMatOperator::Img_Raw_Read (char *filename, int height, int width, int byteperpixel)
{
    // cout << "Img_Raw_Read: " << filename << endl;
    FILE *file;
    if (!(file = fopen(filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);
    Img *pt_image = image;
    return pt_image;
}

Img* ImgMatOperator::Img_Raw_Read (string filename, int height, int width, int byteperpixel)
{
    // cout << "Img_Raw_Read: " << filename << endl;
    char *c_filename = new char[filename.length() + 1];
    strcpy(c_filename, filename.c_str());
    FILE *file;
    if (!(file = fopen(c_filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);
    Img *pt_image = image;
    return pt_image;
}

void ImgMatOperator::Img_Raw_Write (char* filename, Img *pt_image, int height, int width, int byteperpixel)
{
    cout << "Img_Raw_Write: " << filename << endl;
    FILE *file;
    if (!(file = fopen(filename, "wb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    memcpy(image, pt_image, size);
    fwrite(image, sizeof(Img), size, file);
    fclose(file);
}

void ImgMatOperator::Mat_File_Print (Mat mat, string filename)
{
    cout << "Mat_File_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    fout << mat << endl;
    fout.close();
}

void ImgMatOperator::Img_File_Print (Img *image, string filename, int height, int width, int byteperpixel)
{
    cout << "Img_File_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            for (int k = 0; k < byteperpixel; k++)
                fout << (int)*image++ << " ";
        }
        fout << endl;
    }
    fout.close();
}

void ImgMatOperator::Mat_XML_Print(Mat mat, string filename)
{
    cout << "Mat_XML_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    for (int i = 0; i < mat.rows; i++)
    {
        for (int j = 0; j < mat.cols; j++)
            fout << (int)mat.data[i * mat.cols + j] << endl;
    }
    fout.close();
}

Mat ImgMatOperator::Img_To_Mat_Convert (Img *image, int height, int width, int byteperpixel)
{
    cout << "Img_To_Mat_Convert" << endl;
    Mat mat(height, width, CV_8UC1, image);
    return mat;
}

void ImgMatOperator::Mat_Raw_Write_Gray (Mat mat, string filename)
{
    cout << "Mat_Raw_Write_Gray: " << filename << endl;
    const int width = mat.cols;
    const int height = mat.rows;
    Img image[mat.cols * mat.rows];
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
        cerr << "Cannot open file: " << filename << endl;
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++) {
            fout << (Img) mat.at<double>(i, j);
        }
    }
    fout.close();
}

void ImgMatOperator::Mat_Raw_Write_Color (Mat mat, string filename)
{
    cout << "Mat_Raw_Write_Color: " << filename << endl;
    const int width = mat.cols;
    const int height = mat.rows;
    vector<Mat> channels(3);
    split(mat, channels);
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
        cerr << "Cannot open file: " << filename << endl;
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++) {
            fout << (Img)channels[2].at<double>(i, j);
            fout << (Img)channels[1].at<double>(i, j);
            fout << (Img)channels[0].at<double>(i, j);
        }
    }
    fout.close();
}

Mat ImgMatOperator::Mat_Raw_Read (string filename, int height, int width, int byteperpixel) {
    cout << "Mat_Raw_Read: " << filename << endl;
    char *c_filename = new char[filename.length() + 1];
    strcpy(c_filename, filename.c_str());
    Mat mat;
    FILE *file;
    if (!(file = fopen(c_filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);

    if (byteperpixel == 1) {
        double d_image[size];
        int count = 0;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                d_image[count] = (double)image[count];
                count++;
            }
        }
        mat = Mat(height, width, CV_64F, d_image).clone();
    }
    if (byteperpixel == 3) {
        double d_image[size];
        int count = 0;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                for (int k = 0; k < byteperpixel; k++) {
                    if (k == 0) {
                        Img temp = image[count];
                        image[count] = image[count + 2];
                        image[count + 2] = temp;
                    }
                    d_image[count] = (double)image[count];
                    count++;
                }
            }
        }
        mat = Mat(height, width, CV_64FC3, d_image).clone();
    }
    return mat;
}

int *ImgMatOperator::Get_Window(int i, int j, int height, int width, int half_window) {
    // top, bottom, left, right
    int window[4] = {i - half_window, i + half_window, j - half_window, j + 2};
    if (window[0] < 0)
        window[0] = 0;
    if (window[2] < 0)
        window[2] = 0;
    if (window[1] > height - 1)
        window[1] = height - 1;
    if (window[3] > width - 1)
        window[3] = width - 1;
    int *res = window;
    return res;
}

void ImgMatOperator::Test()
{
    cout << "Test" << endl;
    char filename[] = "p1_image/p1_image_a/grass_01.raw";
    Img *pt_image = Img_Raw_Read(filename, 128, 128, 1);
    Img image[128 * 128];
    for (int i = 0; i < 128 * 128 * 1; i++)
        image[i] = pt_image[i];
    strcpy(filename, "test_img_raw_write.raw");
    Img_Raw_Write(filename, image, 128, 128, 1);
    Img_File_Print(image, "test_img_file_print.txt", 128, 128, 1);
    Mat mat = Img_To_Mat_Convert(image, 128, 128, 1);
    Mat_File_Print(mat, "test_mat_file_print.txt");
    Mat_Raw_Write_Gray(mat, "test_mat_raw_write.raw");
    Mat_XML_Print(mat, "test_mat_xml_print.txt");

    Mat mat2 = Mat_Raw_Read("p1_image/p1_image_a/grass_01.raw", 128, 128, 1);
    // cout << "MAT2: " << mat2 << endl << endl;
}


/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Edge Detection
 *
 *
 * Main function:
 * p2_main.cpp
 *
 * Class EdgeDetector:
 * edge_detector.h
 * edge_detector.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * p2c: matlab code
 * prob2c.m
 * detector_SE.m
 */

#ifndef HW2_HELPER_H
#define HW2_HELPER_H

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h>
#include <fstream>
#include <cstring>
#include <opencv2/opencv.hpp>

typedef unsigned char Img;
using namespace cv;
using namespace std;

class ImgMatOperator {
public:
    ImgMatOperator();

    Img* Img_Raw_Read (char *filename, int height, int width, int byteperpixel);
    static Img* Img_Raw_Read (string, int, int, int);
    void Img_Raw_Write (char* filename, Img *image, int height, int width, int byteperpixel);
    void Img_File_Print (Img *image, string filename, int height, int width, int byteperpixel);

    Mat Img_To_Mat_Convert (Img *image, int height, int width, int byteperpixel);

    void Mat_File_Print (Mat mat, string filename);
    void Mat_XML_Print(Mat mat, string filename);
    static void Mat_Raw_Write_Gray (Mat mat, string filename);
    static void Mat_Raw_Write_Color (Mat mat, string filename);
    static Mat Mat_Raw_Read(string filename, int height, int width, int byteperpixel);

    static int *Get_Window(int i, int j, int height, int width, int half_window);
    void Test();
};
#endif //HW2_P1A_H

/* EE569 Homework Assignment #2
 * Date: October 11, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Edge Detection
 *
 *
 * Main function:
 * p2_main.cpp
 *
 * Class EdgeDetector:
 * edge_detector.h
 * edge_detector.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * p2c: matlab code
 * prob2c.m
 * detector_SE.m
 */

/*
 * Problem2. Edge Detection
 * Prob2a. Sobel edge detector and non-maximal suppression
 * prob2b. Canny edge detector
 * prob2c. Structured edge (Matlab code)
 * prob2d. Performance evaluation
 */

#include "edge_detector.h"
using namespace std;

const string FOLDER = "p2_image/";
const int WIDTH = 481;
const int HEIGHT = 321;
const int BYTEPERPIXEL = 3;
const string NAME[2] = {"Farm", "Cougar"};
const string FILENAME[2] =
        {"p2_image/Farm.raw", "p2_image/Cougar.raw"};

// Prob2a. Sobel edge detector and non-maximal suppression
void prob2a() {
    cout << "Problem 2a" << endl;
    for (int i = 0; i < 1; i++) {
        EdgeDetector ed = EdgeDetector(FILENAME[i], HEIGHT, WIDTH, BYTEPERPIXEL);
        ed.ConvertRGB();
        ed.Detector_Sobel(0.1);
        ed.Detector_Sobel(0.15);
    }
}

// Prob2b. Canny edge detector
void prob2b() {
    cout << "Problem 2b" << endl;
    for (int i = 1; i < 2; i++) {
        EdgeDetector ed = EdgeDetector(FILENAME[i], HEIGHT, WIDTH, BYTEPERPIXEL);
        ed.ConvertRGB();
        ed.Detector_Canny(0.3, 0.6);
        ed.Detector_Canny(0.2, 0.7);
        ed.Detector_Canny(0.2, 0.5);
        ed.Detector_Canny(0.4, 0.7);
        ed.Detector_Canny(0.4, 0.5);
    }
}

// Prob2d. Performance evaluation
void prob2d() {
    cout << "Problem 2d" << endl;
    for (int i = 0; i < 2; i++) {
        cout << endl << NAME[i] << endl;
        vector<string> filename_gt;
        for (int j = 0; j < 5; j++) {
            string temp_str = FOLDER + NAME[i] + "_GT" + to_string(j+1) + ".raw";
            filename_gt.push_back(temp_str);
        }
        cout << endl << "p2a: Sobel" << endl;
        EdgeDetector::Evaluation("p2a_result/" + NAME[i] + "_suppression_010.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2a_result/" + NAME[i] + "_suppression_015.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);

        cout << endl << "p2b: Canny" << endl;
        EdgeDetector::Evaluation("p2b_result/" + NAME[i] + "_3_6.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2b_result/" + NAME[i] + "_2_7.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2b_result/" + NAME[i] + "_2_5.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2b_result/" + NAME[i] + "_4_7.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2b_result/" + NAME[i] + "_4_5.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);

        cout << endl << "p2c: SE" << endl;
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_02.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_03.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_04.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_05.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_06.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_07.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_08.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_09.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
        EdgeDetector::Evaluation("p2c_result/" + NAME[i] + "_SE_10.raw", filename_gt, HEIGHT, WIDTH, BYTEPERPIXEL);
    }
}

int main(int argc, char *argv[])
{
    cout << "Problem 2" << endl;
    prob2a();
    prob2b();
    prob2d();
    return 0;
}
% EE569 Homework Assignment #2 
% Date: October. 11th 2015 
% Name: Meiyi Yang
% ID:  6761-0405-85 
% email:  meiyiyan@usc.edu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 2:    Edge Detector
% (c) Structured Edge
% M-file list:   detector_SE.m
%                prob2c.m
% Usage:         run prob2c.m
% Function usage: detector_SE(filename_read, filename, threshold)
% Output image:   Farm_SE_XX.raw, Cougar_SE_XX.raw
% Parameters:   threshold = 0.2:0.1:0.9
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
function G = detector_SE(filename_read, filename_write, threshold)
%% set opts for training (see edgesTrain.m)
opts=edgesTrain();                % default options (good settings)
opts.modelDir='models/';          % model will be in models/forest
opts.modelFnm='modelBsds';        % model name
opts.nPos=5e5; opts.nNeg=5e5;     % decrease to speedup training
opts.useParfor=0;                 % parallelize if sufficient memory

%% train edge detector (~20m/8Gb per tree, proportional to nPos/nNeg)
tic, model=edgesTrain(opts); toc; % will load model if already trained

%% set detection parameters (can set after training)
model.opts.multiscale=1;          % for top accuracy set multiscale=1
model.opts.sharpen=2;             % for top speed set sharpen=0
model.opts.nTreesEval=2;          % for top speed set nTreesEval=1
model.opts.nThreads=4;            % max number threads for evaluation
model.opts.nms=1;                 % set to true to enable nms
%% evaluate edge detector on BSDS500 (see edgesEval.m)
if(0), edgesEval( model, 'show',1, 'name','' ); end
%% read the file
row = 321;
col = 481;
byte = 3;
fin = fopen(filename_read, 'r');
I_read = fread(fin, row * col * byte, 'uchar');
I_read = uint8(I_read);
I = ones(row, col, byte);
count = 0;
for i = 1:row
    for j = 1:col
        for k = 1:byte
            count = count + 1;
            I(i, j, k) = I_read(count, 1);
        end;
    end;
end;
I = uint8(I);
fclose(fin);
%% detect edge and threshold the result
tic, E=edgesDetect(I,model); toc
E_test = reshape(E, row * col, 1);
max = -100;
min = 100;
for i = 1:row*col
    if (E_test(i, 1) > max)
        max = E_test(i , 1);
    end
    if (E_test(i, 1) < min)
        min = E_test(i, 1);
    end
end
E_sort = sort(E_test);
num = floor(row * col * (1 - threshold));
%row_new = floor(num / col + 1);
%col_new = floor(num - (row_new - 1) * col);
threshold_value = E_sort(num, 1);
E_threshold = E;
for i = 1: row
    for j = 1 : col
        if (E_threshold(i, j) > threshold_value)
            E_threshold(i, j) = 0;
        else
            E_threshold(i, j) = 1;
        end
    end
end
%% write the file to raw image
G = E_threshold;
fid = fopen(filename_write,'wb');
% Check if file exists
if (fid == -1)
	error('can not open output image filem press CTRL-C to exit \n');
	pause
end
% Transpose matrix to write file properly
G = G'.* 255;
% Write and close file
count = fwrite(fid, G, 'uchar');
fclose(fid);
% Transpose again to restore matrix
G = G';
% EE569 Homework Assignment #2 
% Date: October. 11th 2015 
% Name: Meiyi Yang
% ID:  6761-0405-85 
% email:  meiyiyan@usc.edu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 2:    Edge Detector
% (c) Structured Edge
% M-file list:   detector_SE.m
%                prob2c.m
% Usage:         run prob2c.m
% Function usage: detector_SE(filename_read, filename, threshold)
% Output image:   Farm_SE_XX.raw, Cougar_SE_XX.raw
% Parameters:   threshold = 0.2:0.1:0.9
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
%% Farm.raw
subplot(3,3,1);
imshow(detector_SE('Farm.raw', 'Farm_SE_02.raw', 0.02));
title('Farm: threshold = 0.02');

subplot(3,3,2);
imshow(detector_SE('Farm.raw', 'Farm_SE_03.raw', 0.03));
title('Farm: threshold = 0.03');

subplot(3,3,3);
imshow(detector_SE('Farm.raw', 'Farm_SE_04.raw', 0.04));
title('Farm: threshold = 0.04');

subplot(3,3,4);
imshow(detector_SE('Farm.raw', 'Farm_SE_05.raw', 0.05));
title('Farm: threshold = 0.05');

subplot(3,3,5);
imshow(detector_SE('Farm.raw', 'Farm_SE_06.raw', 0.06));
title('Farm: threshold = 0.06');

subplot(3,3,6);
imshow(detector_SE('Farm.raw', 'Farm_SE_07.raw', 0.07));
title('Farm: threshold = 0.07');

subplot(3,3,7);
imshow(detector_SE('Farm.raw', 'Farm_SE_08.raw', 0.08));
title('Farm: threshold = 0.08');

subplot(3,3,8);
imshow(detector_SE('Farm.raw', 'Farm_SE_09.raw', 0.09));
title('Farm: threshold = 0.09');

subplot(3,3,9);
imshow(detector_SE('Farm.raw', 'Farm_SE_10.raw', 0.10));
title('Farm: threshold = 0.10');

%% Cougar.raw
figure;
subplot(3,3,1);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_02.raw', 0.02));
title('Cougar: threshold = 0.02');

subplot(3,3,2);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_03.raw', 0.03));
title('Cougar: threshold = 0.03');

subplot(3,3,3);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_04.raw', 0.04));
title('Cougar: threshold = 0.04');

subplot(3,3,4);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_05.raw', 0.05));
title('Cougar: threshold = 0.05');

subplot(3,3,5);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_06.raw', 0.06));
title('Cougar: threshold = 0.06');

subplot(3,3,6);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_07.raw', 0.07));
title('Cougar: threshold = 0.07');

subplot(3,3,7);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_08.raw', 0.08));
title('Cougar: threshold = 0.08');

subplot(3,3,8);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_09.raw', 0.09));
title('Cougar: threshold = 0.09');

subplot(3,3,9);
imshow(detector_SE('Cougar.raw', 'Cougar_SE_10.raw', 0.10));
title('Cougar: threshold = 0.10');
