/* EE569 Homework Assignment #2
 * Date: October 14, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Image Segmentation
 *
 * Main function:
 * p2_main.cpp
 *
 * Class slic:
 * slic.h
 * slic.cpp
 *
 * Function Meanshift
 * meanshift.h
 * meanshift.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * MATLAB code
 * p3b.m
 * p3c.m
 * run_cpp.m
 * run_evaluation.m
 */

#include "hw2_helper.h"

ImgMatOperator::ImgMatOperator()
{

}

Img* ImgMatOperator::Img_Raw_Read (char *filename, int height, int width, int byteperpixel)
{
    // cout << "Img_Raw_Read: " << filename << endl;
    FILE *file;
    if (!(file = fopen(filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);
    Img *pt_image = image;
    return pt_image;
}

Img* ImgMatOperator::Img_Raw_Read (string filename, int height, int width, int byteperpixel)
{
    // cout << "Img_Raw_Read: " << filename << endl;
    char *c_filename = new char[filename.length() + 1];
    strcpy(c_filename, filename.c_str());
    FILE *file;
    if (!(file = fopen(c_filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);
    Img *pt_image = image;
    return pt_image;
}

void ImgMatOperator::Img_Raw_Write (char* filename, Img *pt_image, int height, int width, int byteperpixel)
{
    cout << "Img_Raw_Write: " << filename << endl;
    FILE *file;
    if (!(file = fopen(filename, "wb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    memcpy(image, pt_image, size);
    fwrite(image, sizeof(Img), size, file);
    fclose(file);
}

void ImgMatOperator::Mat_File_Print (Mat mat, string filename)
{
    cout << "Mat_File_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    fout << mat << endl;
    fout.close();
}

void ImgMatOperator::Img_File_Print (Img *image, string filename, int height, int width, int byteperpixel)
{
    cout << "Img_File_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++)
        {
            for (int k = 0; k < byteperpixel; k++)
                fout << (int)*image++ << " ";
        }
        fout << endl;
    }
    fout.close();
}

void ImgMatOperator::Mat_XML_Print(Mat mat, string filename)
{
    cout << "Mat_XML_Print: " << filename << endl;
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
    {
        cerr << "Cannot open file: " << filename << endl;
    }
    for (int i = 0; i < mat.rows; i++)
    {
        for (int j = 0; j < mat.cols; j++)
            fout << (int)mat.data[i * mat.cols + j] << endl;
    }
    fout.close();
}

Mat ImgMatOperator::Img_To_Mat_Convert (Img *image, int height, int width, int byteperpixel)
{
    cout << "Img_To_Mat_Convert" << endl;
    Mat mat(height, width, CV_8UC1, image);
    return mat;
}

void ImgMatOperator::Mat_Raw_Write_Gray (Mat mat, string filename)
{
    cout << "Mat_Raw_Write_Gray: " << filename << endl;
    const int width = mat.cols;
    const int height = mat.rows;
    Img image[mat.cols * mat.rows];
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
        cerr << "Cannot open file: " << filename << endl;
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++) {
            fout << (Img) mat.at<double>(i, j);
        }
    }
    fout.close();
}

void ImgMatOperator::Mat_Raw_Write_Color (Mat mat, string filename)
{
    cout << "Mat_Raw_Write_Color: " << filename << endl;
    const int width = mat.cols;
    const int height = mat.rows;
    vector<Mat> channels(3);
    split(mat, channels);
    fstream fout;
    fout.open(filename, ios_base::out);
    if (!fout.is_open())
        cerr << "Cannot open file: " << filename << endl;
    for (int i = 0; i < height; i++)
    {
        for (int j = 0; j < width; j++) {
            fout << (Img)channels[2].at<unsigned char>(i, j);
            fout << (Img)channels[1].at<unsigned char>(i, j);
            fout << (Img)channels[0].at<unsigned char>(i, j);
            //cout << (int)channels[0].at<unsigned char>(i, j) << " ";
        }
        //cout << endl;
    }
    fout.close();
}

Mat ImgMatOperator::Mat_Raw_Read (string filename, int height, int width, int byteperpixel) {
    cout << "Mat_Raw_Read: " << filename << endl;
    char *c_filename = new char[filename.length() + 1];
    strcpy(c_filename, filename.c_str());
    Mat mat;
    FILE *file;
    if (!(file = fopen(c_filename, "rb")))
    {
        cout << "Cannot open file: " << filename << endl;
        exit(1);
    }
    size_t size = height * width * byteperpixel;
    Img image[size];
    fread(image, sizeof(Img), size, file);
    fclose(file);

    if (byteperpixel == 1) {
        double d_image[size];
        int count = 0;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                d_image[count] = (double)image[count];
                count++;
            }
        }
        mat = Mat(height, width, CV_64F, d_image).clone();
    }
    if (byteperpixel == 3) {
        cout << "RGB image" << endl;
        Img d_image[size];
        int count = 0;
        for (int i = 0; i < height; i++) {
            for (int j = 0; j < width; j++) {
                for (int k = 0; k < byteperpixel; k++) {
                    if (k == 0) {
                        Img temp = image[count];
                        image[count] = image[count + 2];
                        image[count + 2] = temp;
                    }
                    d_image[count] = (Img)image[count];
                    count++;
                    //cout << image[count] << " ";
                }
            }
            //cout << endl;
        }
        mat = Mat(height, width, CV_8UC3, d_image).clone();
    }
    return mat;
}

int *ImgMatOperator::Get_Window(int i, int j, int height, int width, int half_window) {
    // top, bottom, left, right
    int window[4] = {i - half_window, i + half_window, j - half_window, j + 2};
    if (window[0] < 0)
        window[0] = 0;
    if (window[2] < 0)
        window[2] = 0;
    if (window[1] > height - 1)
        window[1] = height - 1;
    if (window[3] > width - 1)
        window[3] = width - 1;
    int *res = window;
    return res;
}

void ImgMatOperator::Test()
{
    cout << "Test" << endl;
    char filename[] = "p1_image/p1_image_a/grass_01.raw";
    Img *pt_image = Img_Raw_Read(filename, 128, 128, 1);
    Img image[128 * 128];
    for (int i = 0; i < 128 * 128 * 1; i++)
        image[i] = pt_image[i];
    strcpy(filename, "test_img_raw_write.raw");
    Img_Raw_Write(filename, image, 128, 128, 1);
    Img_File_Print(image, "test_img_file_print.txt", 128, 128, 1);
    Mat mat = Img_To_Mat_Convert(image, 128, 128, 1);
    Mat_File_Print(mat, "test_mat_file_print.txt");
    Mat_Raw_Write_Gray(mat, "test_mat_raw_write.raw");
    Mat_XML_Print(mat, "test_mat_xml_print.txt");

    Mat mat2 = Mat_Raw_Read("p1_image/p1_image_a/grass_01.raw", 128, 128, 1);
    // cout << "MAT2: " << mat2 << endl << endl;
}
/* EE569 Homework Assignment #2
 * Date: October 14, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Image Segmentation
 *
 * Main function:
 * p2_main.cpp
 *
 * Class slic:
 * slic.h
 * slic.cpp
 *
 * Function Meanshift
 * meanshift.h
 * meanshift.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * MATLAB code
 * p3b.m
 * p3c.m
 * run_cpp.m
 * run_evaluation.m
 */

#ifndef HW2_HELPER_H
#define HW2_HELPER_H

#include <stdio.h>
#include <iostream>
#include <stdlib.h>
#include <math.h>
#include <fstream>
#include <cstring>
#include <opencv2/opencv.hpp>

typedef unsigned char Img;
using namespace cv;
using namespace std;

class ImgMatOperator {
public:
    ImgMatOperator();

    Img* Img_Raw_Read (char *filename, int height, int width, int byteperpixel);
    static Img* Img_Raw_Read (string, int, int, int);
    void Img_Raw_Write (char* filename, Img *image, int height, int width, int byteperpixel);
    void Img_File_Print (Img *image, string filename, int height, int width, int byteperpixel);

    Mat Img_To_Mat_Convert (Img *image, int height, int width, int byteperpixel);

    void Mat_File_Print (Mat mat, string filename);
    void Mat_XML_Print(Mat mat, string filename);
    static void Mat_Raw_Write_Gray (Mat mat, string filename);
    static void Mat_Raw_Write_Color (Mat mat, string filename);
    static Mat Mat_Raw_Read(string filename, int height, int width, int byteperpixel);

    static int *Get_Window(int i, int j, int height, int width, int half_window);
    void Test();
};
#endif //HW2_P1A_H

/* EE569 Homework Assignment #2
 * Date: October 14, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Image Segmentation
 *
 * Main function:
 * p2_main.cpp
 *
 * Class slic:
 * slic.h
 * slic.cpp
 *
 * Function Meanshift
 * meanshift.h
 * meanshift.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * MATLAB code
 * p3b.m
 * p3c.m
 * run_cpp.m
 * run_evaluation.m
 */
/* slic.h.
 *
 * Written by: Pascal Mettes.
 *
 * This file contains the class elements of the class Slic. This class is an
 * implementation of the SLIC Superpixel algorithm by Achanta et al. [PAMI'12,
 * vol. 34, num. 11, pp. 2274-2282].
 *
 * This implementation is created for the specific purpose of creating
 * over-segmentations in an OpenCV-based environment.
 * From: https://github.com/PSMM/SLIC-Superpixels
 */

/* meanshift.h
 * Author: Kanglai Qian
 * From: https://github.com/qiankanglai/opencv.meanshift
*/

#include "MeanShift.h"

RAList::RAList( void )
{
    label			= -1;
    next			= 0;	//NULL
}

RAList::~RAList( void )
{}

int RAList::Insert(RAList *entry)
{
    if(!next)
    {
        next		= entry;
        entry->next = 0;
        return 0;
    }
    if(next->label > entry->label)
    {
        entry->next	= next;
        next		= entry;
        return 0;
    }
    exists	= 0;
    cur		= next;
    while(cur)
    {
        if(entry->label == cur->label)
        {
            exists = 1;
            break;
        }
        else if((!(cur->next))||(cur->next->label > entry->label))
        {
            entry->next	= cur->next;
            cur->next	= entry;
            break;
        }
        cur = cur->next;
    }
    return (int)(exists);
}

int MeanShift(const IplImage* img, int **labels, int hs, double hc)
{
    const int spatial_radius = hs;
    const double color_radius = hc;

    DECLARE_TIMING(timer);
    START_TIMING(timer);

    int level = 1;
    double color_radius2=color_radius*color_radius;
    int minRegion = 50;

    // use Lab rather than L*u*v!
    // since Luv may produce noise points
    IplImage *result = cvCreateImage(cvGetSize(img),img->depth,img->nChannels);
    cvCvtColor(img, result, CV_RGB2Lab);

    // Step One. Filtering stage of meanshift segmentation
    // http://rsbweb.nih.gov/ij/plugins/download/Mean_Shift.java
    for(int i=0;i<img->height;i++)
        for(int j=0;j<img->width;j++)
        {
            int ic = i;
            int jc = j;
            int icOld, jcOld;
            float LOld, UOld, VOld;
            float L = (float)((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 0];
            float U = (float)((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 1];
            float V = (float)((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 2];
            // in the case of 8-bit and 16-bit images R, G and B are converted to floating-point format and scaled to fit 0 to 1 range
            // http://opencv.willowgarage.com/documentation/c/miscellaneous_image_transformations.html
            L = L*100/255;
            U = U-128;
            V = V-128;
            double shift = 5;
            for (int iters=0;shift > 3 && iters < 100;iters++)
            {
                icOld = ic;
                jcOld = jc;
                LOld = L;
                UOld = U;
                VOld = V;

                float mi = 0;
                float mj = 0;
                float mL = 0;
                float mU = 0;
                float mV = 0;
                int num=0;

                int i2from = max(0,i-spatial_radius), i2to = min(img->height, i+spatial_radius+1);
                int j2from = max(0,j-spatial_radius), j2to = min(img->width, j+spatial_radius+1);
                for (int i2=i2from; i2 < i2to;i2++) {
                    for (int j2=j2from; j2 < j2to; j2++) {
                        float L2 = (float)((uchar *)(result->imageData + i2*img->widthStep))[j2*result->nChannels + 0],
                                U2 = (float)((uchar *)(result->imageData + i2*img->widthStep))[j2*result->nChannels + 1],
                                V2 = (float)((uchar *)(result->imageData + i2*img->widthStep))[j2*result->nChannels + 2];
                        L2 = L2*100/255;
                        U2 = U2-128;
                        V2 = V2-128;

                        double dL = L2 - L;
                        double dU = U2 - U;
                        double dV = V2 - V;
                        if (dL*dL+dU*dU+dV*dV <= color_radius2) {
                            mi += i2;
                            mj += j2;
                            mL += L2;
                            mU += U2;
                            mV += V2;
                            num++;
                        }
                    }
                }
                float num_ = 1.f/num;
                L = mL*num_;
                U = mU*num_;
                V = mV*num_;
                ic = (int) (mi*num_+0.5);
                jc = (int) (mj*num_+0.5);
                int di = ic-icOld;
                int dj = jc-jcOld;
                double dL = L-LOld;
                double dU = U-UOld;
                double dV = V-VOld;

                shift = di*di+dj*dj+dL*dL+dU*dU+dV*dV;
            }

            L = L*255/100;
            U = U+128;
            V = V+128;
            ((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 0] = (uchar)L;
            ((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 1] = (uchar)U;
            ((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 2] = (uchar)V;
        }

    IplImage *tobeshow = cvCreateImage(cvGetSize(img),img->depth,img->nChannels);
    cvCvtColor(result, tobeshow, CV_Lab2RGB);
    cvSaveImage("filtered.png", tobeshow);
    cvReleaseImage(&tobeshow);

    // Step Two. Cluster
    // Connect
    int regionCount = 0;
    int *modePointCounts = new int[img->height*img->width];
    memset(modePointCounts, 0, img->width*img->height*sizeof(int));
    float *mode = new float[img->height*img->width*3];
    {
        int label = -1;
        for(int i=0;i<img->height;i++)
            for(int j=0;j<img->width;j++)
                labels[i][j] = -1;
        for(int i=0;i<img->height;i++)
            for(int j=0;j<img->width;j++)
                if(labels[i][j]<0)
                {
                    labels[i][j] = ++label;
                    float L = (float)((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 0],
                            U = (float)((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 1],
                            V = (float)((uchar *)(result->imageData + i*img->widthStep))[j*result->nChannels + 2];
                    mode[label*3+0] = L*100/255;
                    mode[label*3+1] = 354*U/255-134;
                    mode[label*3+2] = 256*V/255-140;
                    // Fill
                    std::stack<CvPoint> neighStack;
                    neighStack.push(cvPoint(i,j));
                    const int dxdy[][2] = {{-1,-1},{-1,0},{-1,1},{0,-1},{0,1},{1,-1},{1,0},{1,1}};
                    while(!neighStack.empty())
                    {
                        CvPoint p = neighStack.top();
                        neighStack.pop();
                        for(int k=0;k<8;k++)
                        {
                            int i2 = p.x+dxdy[k][0], j2 = p.y+dxdy[k][1];
                            if(i2>=0 && j2>=0 && i2<img->height && j2<img->width && labels[i2][j2]<0 && color_distance(result, i,j,i2,j2)<color_radius2)
                            {
                                labels[i2][j2] = label;
                                neighStack.push(cvPoint(i2,j2));
                                modePointCounts[label]++;
                                L = (float)((uchar *)(result->imageData + i2*img->widthStep))[j2*result->nChannels + 0];
                                U = (float)((uchar *)(result->imageData + i2*img->widthStep))[j2*result->nChannels + 1];
                                V = (float)((uchar *)(result->imageData + i2*img->widthStep))[j2*result->nChannels + 2];
                                mode[label*3+0] += L*100/255;
                                mode[label*3+1] += 354*U/255-134;
                                mode[label*3+2] += 256*V/255-140;
                            }
                        }
                    }
                    mode[label*3+0] /= modePointCounts[label];
                    mode[label*3+1] /= modePointCounts[label];
                    mode[label*3+2] /= modePointCounts[label];
                }
        //current Region count
        regionCount = label+1;
    }
    std::cout<<"Mean Shift(Connect):"<<regionCount<<std::endl;
    int oldRegionCount = regionCount;

    // TransitiveClosure
    for(int counter = 0, deltaRegionCount = 1; counter<5 && deltaRegionCount>0; counter++)
    {
        // 1.Build RAM using classifiction structure
        RAList *raList = new RAList [regionCount], *raPool = new RAList [10*regionCount];	//10 is hard coded!
        for(int i = 0; i < regionCount; i++)
        {
            raList[i].label = i;
            raList[i].next = NULL;
        }
        for(int i = 0; i < regionCount*10-1; i++)
        {
            raPool[i].next = &raPool[i+1];
        }
        raPool[10*regionCount-1].next = NULL;
        RAList	*raNode1, *raNode2, *oldRAFreeList, *freeRAList = raPool;
        for(int i=0;i<img->height;i++)
            for(int j=0;j<img->width;j++)
            {
                if(i>0 && labels[i][j]!=labels[i-1][j])
                {
                    // Get 2 free node
                    raNode1			= freeRAList;
                    raNode2			= freeRAList->next;
                    oldRAFreeList	= freeRAList;
                    freeRAList		= freeRAList->next->next;
                    // connect the two region
                    raNode1->label	= labels[i][j];
                    raNode2->label	= labels[i-1][j];
                    if(raList[labels[i][j]].Insert(raNode2))	//already exists!
                        freeRAList = oldRAFreeList;
                    else
                        raList[labels[i-1][j]].Insert(raNode1);
                }
                if(j>0 && labels[i][j]!=labels[i][j-1])
                {
                    // Get 2 free node
                    raNode1			= freeRAList;
                    raNode2			= freeRAList->next;
                    oldRAFreeList	= freeRAList;
                    freeRAList		= freeRAList->next->next;
                    // connect the two region
                    raNode1->label	= labels[i][j];
                    raNode2->label	= labels[i][j-1];
                    if(raList[labels[i][j]].Insert(raNode2))
                        freeRAList = oldRAFreeList;
                    else
                        raList[labels[i][j-1]].Insert(raNode1);
                }
            }

        // 2.Treat each region Ri as a disjoint set
        for(int i = 0; i < regionCount; i++)
        {
            RAList	*neighbor = raList[i].next;
            while(neighbor)
            {
                if(color_distance(&mode[3*i], &mode[3*neighbor->label])<color_radius2)
                {
                    int iCanEl = i, neighCanEl	= neighbor->label;
                    while(raList[iCanEl].label != iCanEl) iCanEl = raList[iCanEl].label;
                    while(raList[neighCanEl].label != neighCanEl) neighCanEl = raList[neighCanEl].label;
                    if(iCanEl<neighCanEl)
                        raList[neighCanEl].label = iCanEl;
                    else
                    {
                        //raList[raList[iCanEl].label].label = iCanEl;
                        raList[iCanEl].label = neighCanEl;
                    }
                }
                neighbor = neighbor->next;
            }
        }
        // 3. Union Find
        for(int i = 0; i < regionCount; i++)
        {
            int iCanEl	= i;
            while(raList[iCanEl].label != iCanEl) iCanEl	= raList[iCanEl].label;
            raList[i].label	= iCanEl;
        }
        // 4. Traverse joint sets, relabeling image.
        int *modePointCounts_buffer = new int[regionCount];
        memset(modePointCounts_buffer, 0, regionCount*sizeof(int));
        float *mode_buffer = new float[regionCount*3];
        int	*label_buffer = new int[regionCount];

        for(int i=0;i<regionCount; i++)
        {
            label_buffer[i]	= -1;
            mode_buffer[i*3+0] = 0;
            mode_buffer[i*3+1] = 0;
            mode_buffer[i*3+2] = 0;
        }
        for(int i=0;i<regionCount; i++)
        {
            int iCanEl	= raList[i].label;
            modePointCounts_buffer[iCanEl] += modePointCounts[i];
            for(int k=0;k<3;k++)
                mode_buffer[iCanEl*3+k] += mode[i*3+k]*modePointCounts[i];
        }
        int	label = -1;
        for(int i = 0; i < regionCount; i++)
        {
            int iCanEl	= raList[i].label;
            if(label_buffer[iCanEl] < 0)
            {
                label_buffer[iCanEl]	= ++label;

                for(int k = 0; k < 3; k++)
                    mode[label*3+k]	= (mode_buffer[iCanEl*3+k])/(modePointCounts_buffer[iCanEl]);

                modePointCounts[label]	= modePointCounts_buffer[iCanEl];
            }
        }
        regionCount = label+1;
        for(int i = 0; i < img->height; i++)
            for(int j = 0; j < img->width; j++)
                labels[i][j]	= label_buffer[raList[labels[i][j]].label];

        delete [] mode_buffer;
        delete [] modePointCounts_buffer;
        delete [] label_buffer;

        //Destroy RAM
        delete[] raList;
        delete[] raPool;

        deltaRegionCount = oldRegionCount - regionCount;
        oldRegionCount = regionCount;
        std::cout<<"Mean Shift(TransitiveClosure):"<<regionCount<<std::endl;
    }

    // Prune
    {
        int *modePointCounts_buffer = new int[regionCount];
        float *mode_buffer = new float[regionCount*3];
        int	*label_buffer = new int [regionCount];
        int minRegionCount;

        do{
            minRegionCount = 0;
            // Build RAM again
            RAList *raList = new RAList [regionCount], *raPool = new RAList [10*regionCount];	//10 is hard coded!
            for(int i = 0; i < regionCount; i++)
            {
                raList[i].label = i;
                raList[i].next = NULL;
            }
            for(int i = 0; i < regionCount*10-1; i++)
            {
                raPool[i].next = &raPool[i+1];
            }
            raPool[10*regionCount-1].next = NULL;
            RAList	*raNode1, *raNode2, *oldRAFreeList, *freeRAList = raPool;
            for(int i=0;i<img->height;i++)
                for(int j=0;j<img->width;j++)
                {
                    if(i>0 && labels[i][j]!=labels[i-1][j])
                    {
                        // Get 2 free node
                        raNode1			= freeRAList;
                        raNode2			= freeRAList->next;
                        oldRAFreeList	= freeRAList;
                        freeRAList		= freeRAList->next->next;
                        // connect the two region
                        raNode1->label	= labels[i][j];
                        raNode2->label	= labels[i-1][j];
                        if(raList[labels[i][j]].Insert(raNode2))	//already exists!
                            freeRAList = oldRAFreeList;
                        else
                            raList[labels[i-1][j]].Insert(raNode1);
                    }
                    if(j>0 && labels[i][j]!=labels[i][j-1])
                    {
                        // Get 2 free node
                        raNode1			= freeRAList;
                        raNode2			= freeRAList->next;
                        oldRAFreeList	= freeRAList;
                        freeRAList		= freeRAList->next->next;
                        // connect the two region
                        raNode1->label	= labels[i][j];
                        raNode2->label	= labels[i][j-1];
                        if(raList[labels[i][j]].Insert(raNode2))
                            freeRAList = oldRAFreeList;
                        else
                            raList[labels[i][j-1]].Insert(raNode1);
                    }
                }
            // Find small regions
            for(int i = 0; i < regionCount; i++)
                if(modePointCounts[i] < minRegion)
                {
                    minRegionCount++;
                    RAList *neighbor = raList[i].next;
                    int candidate = neighbor->label;
                    float minDistance = color_distance(&mode[3*i], &mode[3*candidate]);
                    neighbor = neighbor->next;
                    while(neighbor)
                    {
                        float minDistance2 = color_distance(&mode[3*i], &mode[3*neighbor->label]);
                        if(minDistance2<minDistance)
                        {
                            minDistance = minDistance2;
                            candidate = neighbor->label;
                        }
                        neighbor = neighbor->next;
                    }
                    int iCanEl = i, neighCanEl	= candidate;
                    while(raList[iCanEl].label != iCanEl) iCanEl = raList[iCanEl].label;
                    while(raList[neighCanEl].label != neighCanEl) neighCanEl = raList[neighCanEl].label;
                    if(iCanEl < neighCanEl)
                        raList[neighCanEl].label	= iCanEl;
                    else
                    {
                        //raList[raList[iCanEl].label].label	= neighCanEl;
                        raList[iCanEl].label = neighCanEl;
                    }
                }
            for(int i = 0; i < regionCount; i++)
            {
                int iCanEl	= i;
                while(raList[iCanEl].label != iCanEl)
                    iCanEl	= raList[iCanEl].label;
                raList[i].label	= iCanEl;
            }
            memset(modePointCounts_buffer, 0, regionCount*sizeof(int));
            for(int i = 0; i < regionCount; i++)
            {
                label_buffer[i]	= -1;
                mode_buffer[3*i+0]	= 0;
                mode_buffer[3*i+1]	= 0;
                mode_buffer[3*i+2]	= 0;
            }
            for(int i=0;i<regionCount; i++)
            {
                int iCanEl	= raList[i].label;
                modePointCounts_buffer[iCanEl] += modePointCounts[i];
                for(int k=0;k<3;k++)
                    mode_buffer[iCanEl*3+k] += mode[i*3+k]*modePointCounts[i];
            }
            int	label = -1;
            for(int i = 0; i < regionCount; i++)
            {
                int iCanEl	= raList[i].label;
                if(label_buffer[iCanEl] < 0)
                {
                    label_buffer[iCanEl]	= ++label;

                    for(int k = 0; k < 3; k++)
                        mode[label*3+k]	= (mode_buffer[iCanEl*3+k])/(modePointCounts_buffer[iCanEl]);

                    modePointCounts[label]	= modePointCounts_buffer[iCanEl];
                }
            }
            regionCount = label+1;
            for(int i = 0; i < img->height; i++)
                for(int j = 0; j < img->width; j++)
                    labels[i][j]	= label_buffer[raList[labels[i][j]].label];

            //Destroy RAM
            delete[] raList;
            delete[] raPool;
            std::cout<<"Mean Shift(Prune):"<<regionCount<<std::endl;
        }while(minRegionCount > 0);

        delete [] mode_buffer;
        delete [] modePointCounts_buffer;
        delete [] label_buffer;
    }

    // Output
    STOP_TIMING(timer);
    std::cout<<"Mean Shift(ms):"<<GET_TIMING(timer)<<std::endl;

    cvReleaseImage(&result);
    delete []mode;
    delete []modePointCounts;
    return regionCount;
}
/* EE569 Homework Assignment #2
 * Date: October 14, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Image Segmentation
 *
 * Main function:
 * p2_main.cpp
 *
 * Class slic:
 * slic.h
 * slic.cpp
 *
 * Function Meanshift
 * meanshift.h
 * meanshift.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * MATLAB code
 * p3b.m
 * p3c.m
 * run_cpp.m
 * run_evaluation.m
 */
/* slic.h.
 *
 * Written by: Pascal Mettes.
 *
 * This file contains the class elements of the class Slic. This class is an
 * implementation of the SLIC Superpixel algorithm by Achanta et al. [PAMI'12,
 * vol. 34, num. 11, pp. 2274-2282].
 *
 * This implementation is created for the specific purpose of creating
 * over-segmentations in an OpenCV-based environment.
 * From: https://github.com/PSMM/SLIC-Superpixels
 */

/* meanshift.h
 * Author: Kanglai Qian
 * From: https://github.com/qiankanglai/opencv.meanshift
*/


#include "opencv2/core/core.hpp"
#include "opencv2/highgui/highgui.hpp"
#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/imgproc/imgproc_c.h"

#define DECLARE_TIMING(s)  int64 timeStart_##s; double timeDiff_##s; double timeTally_##s = 0; int countTally_##s = 0
#define START_TIMING(s)    timeStart_##s = cvGetTickCount()
#define STOP_TIMING(s) 	   timeDiff_##s = (double)(cvGetTickCount() - timeStart_##s); timeTally_##s += timeDiff_##s; countTally_##s++
#define GET_TIMING(s) 	   (double)(timeDiff_##s / (cvGetTickFrequency()*1000.0))
#define GET_AVERAGE_TIMING(s)   (double)(countTally_##s ? timeTally_##s/ ((double)countTally_##s * cvGetTickFrequency()*1000.0) : 0)
#define CLEAR_AVERAGE_TIMING(s) timeTally_##s = 0; countTally_##s = 0


#include <vector>
#include <stack>
#include <iostream>
#include <cmath>

using namespace cv;

// Distance used in Mean Shift
inline int color_distance( const IplImage* img, int x1, int y1, int x2, int y2 )
{
    int r = ((uchar *)(img->imageData + x1*img->widthStep))[y1*img->nChannels + 0]
            - ((uchar *)(img->imageData + x2*img->widthStep))[y2*img->nChannels + 0];
    int g = ((uchar *)(img->imageData + x1*img->widthStep))[y1*img->nChannels + 1]
            - ((uchar *)(img->imageData + x2*img->widthStep))[y2*img->nChannels + 1];
    int b = ((uchar *)(img->imageData + x1*img->widthStep))[y1*img->nChannels + 2]
            - ((uchar *)(img->imageData + x2*img->widthStep))[y2*img->nChannels + 2];
    return r*r+g*g+b*b;
}
inline float color_distance( const float* a, const float* b)
{
    float l = a[0]-b[0], u=a[1]-b[1], v=a[2]-b[2];
    return l*l+u*u+v*v;
}
inline float color_distance( const Vec3f& a, const Vec3f& b)
{
    float l = a.val[0]-b.val[0], u=a.val[1]-b.val[1], v=a.val[2]-b.val[2];
    return l*l+u*u+v*v;
}
inline int spatial_distance( const CvPoint& q, const CvPoint& p )
{
    int a = q.x-p.x, b=q.y-p.y;
    return a*a+b*b;
}
inline int getLabel( std::vector<int>& unionfind, int l )
{
    int r = unionfind[l];
    if(unionfind[r] == r)
        return r;
    else
    {
        unionfind[l] = getLabel(unionfind, unionfind[r]);
        return unionfind[l];
    }
}
inline int getLabel2( std::vector<int>& unionfind, int l )
{
    int r = unionfind[l];
    if(r<0)
        return r;
    else
    {
        unionfind[l] = getLabel2(unionfind, r);
        return unionfind[l];
    }
}


int MeanShift(const IplImage* img, int **labels, int, double);

// RAList from EDISON

class RAList {
    // This is cut from Mean Shift Analysis Library, Implemented by Chris M. Christoudias, Bogdan Georgescu
public:
    int		label;
    RAList	*next;
    RAList( void );
    ~RAList( void );
    int Insert(RAList*);

private:
    ///////current and previous pointer/////
    RAList	*cur, *prev;
    unsigned char exists;

};
/* EE569 Homework Assignment #2
 * Date: October 14, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Image Segmentation
 *
 * Main function:
 * p2_main.cpp
 *
 * Class slic:
 * slic.h
 * slic.cpp
 *
 * Function Meanshift
 * meanshift.h
 * meanshift.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * MATLAB code
 * p3b.m
 * p3c.m
 * run_cpp.m
 * run_evaluation.m
 */

/* slic.h.
 *
 * Written by: Pascal Mettes.
 *
 * This file contains the class elements of the class Slic. This class is an
 * implementation of the SLIC Superpixel algorithm by Achanta et al. [PAMI'12,
 * vol. 34, num. 11, pp. 2274-2282].
 *
 * This implementation is created for the specific purpose of creating
 * over-segmentations in an OpenCV-based environment.
 * From: https://github.com/PSMM/SLIC-Superpixels
 */

/* meanshift.h
 * Author: Kanglai Qian
 * From: https://github.com/qiankanglai/opencv.meanshift
 */


#include <opencv/cv.h>
#include <opencv/highgui.h>

#include "opencv2/core/cuda.hpp"
#include "opencv2/imgproc.hpp"
#include <stdio.h>
#include <math.h>
#include <vector>
#include <float.h>


#include "hw2_helper.h"
#include "slic.h"
#include "meanshift.h"

using namespace cv;
using namespace std;


const string FOLDER = "p3_image/";
const string LABLE1 = "Man";
const string LABLE2 = "Rhinos";

/*
 * @para
 * filename read : raw image data
 * filename_write: raw image write to
 * nr_superpixels: number of superpixels
 * nc: weight-factors
 */
void Run_Slic(string filename_read, string filename_write, int nr_superpixels, int nc, int height, int width, int byte) {
  /* Load the image and convert to Lab colour space. */
  Mat mat_original = ImgMatOperator::Mat_Raw_Read(filename_read, height, width, byte);
  IplImage image_original = mat_original;
  IplImage *lab_image = cvCloneImage(&image_original);
  cvCvtColor(&image_original, lab_image, CV_BGR2Lab);

  /* Yield the number of superpixels and weight-factors from the user. */
  int w = image_original.width, h = image_original.height;
  double step = sqrt((w * h) / (double) nr_superpixels);

  /* Perform the SLIC superpixel algorithm. */
  Slic slic;
  slic.generate_superpixels(lab_image, step, nc);
  slic.create_connectivity(lab_image);
  slic.display_contours(&image_original, CV_RGB(255,0,0));
  //slic.colour_with_cluster_means(&image_original);

  // Write to the file and show the image
  IplImage *image_result = &image_original;
  Mat mat_result = cvarrToMat(image_result).clone();
  ImgMatOperator::Mat_Raw_Write_Color(mat_result, filename_write);
    string str = "SLIC: " + to_string(nr_superpixels) + ", " + to_string(nc);
  //imshow(str, mat_result);
  //waitKey(0);
}


/*
 * @para
 * filename read : raw image data
 * filename_write: raw image write to
 * nr_superpixels: number of superpixels
 * nc: weight-factors
 */
void Run_MeanShift(string filename_read, string filename_write, int hs, double hc, int height, int width, int byte) {
    cout << "mean shift" << endl;
    Mat mat_original = ImgMatOperator::Mat_Raw_Read(filename_read, height, width, byte);
    IplImage image_original = mat_original;
    IplImage *img = cvCloneImage(&image_original);

    // Mean shift
    int **ilabels = new int *[img->height];
    for (int i = 0; i < img->height; i++)
        ilabels[i] = new int[img->width];
    int regionCount = MeanShift(img, ilabels, hs, hc);
    vector<int> color(regionCount);
    CvRNG rng = cvRNG(cvGetTickCount());
    for (int i = 0; i < regionCount; i++) {
        color[i] = cvRandInt(&rng);
    }

    // Draw random color
    for (int i = 0; i < img->height; i++) {
        for (int j = 0; j < img->width; j++) {
            int cl = ilabels[i][j];
            ((uchar *) (img->imageData + i * img->widthStep))[j * img->nChannels + 0] = (color[cl]) & 255;
            ((uchar *) (img->imageData + i * img->widthStep))[j * img->nChannels + 1] = (color[cl] >> 8) & 255;
            ((uchar *) (img->imageData + i * img->widthStep))[j * img->nChannels + 2] = (color[cl] >> 16) & 255;
        }
    }

    // Write to the file and show the image
    IplImage *image_result = img;
    Mat mat_result = cvarrToMat(image_result).clone();
    ImgMatOperator::Mat_Raw_Write_Color(mat_result, filename_write);
    string str = "MS: " + filename_read + to_string(hs) + ", " + to_string(hc);
    imshow(str, mat_result);
    waitKey(0);
    cvDestroyWindow("MeanShift");
    cvReleaseImage(&img);
}


void p3a2() {
  string filename = FOLDER + LABLE2 + ".raw";
    int height = 481 ;
    int width = 321;
    
    // test parameter: superpixel
    Run_Slic(filename, "Rhinos_100_10_grid.raw", 100, 10, width, height, 3);
    Run_Slic(filename, "Rhinos_200_10_grid.raw", 200, 10, width, height, 3);
    Run_Slic(filename, "Rhinos_300_10_grid.raw", 300, 10, width, height, 3);
    Run_Slic(filename, "Rhinos_400_10_grid.raw", 400, 10, width, height, 3);
    Run_Slic(filename, "Rhinos_100_50_grid.raw", 100, 50, width, height, 3);
    Run_Slic(filename, "Rhinos_200_50_grid.raw", 200, 50, width, height, 3);
    Run_Slic(filename, "Rhinos_300_50_grid.raw", 300, 50, width, height, 3);
    Run_Slic(filename, "Rhinos_400_50_grid.raw", 400, 50, width, height, 3);
    Run_Slic(filename, "Rhinos_100_100_grid.raw", 100, 100, width, height, 3);
    Run_Slic(filename, "Rhinos_200_100_grid.raw", 200, 100, width, height, 3);
    Run_Slic(filename, "Rhinos_300_100_grid.raw", 300, 100, width, height, 3);
    Run_Slic(filename, "Rhinos_400_100_grid.raw", 400, 100, width, height, 3);
    Run_Slic(filename, "Rhinos_100_200_grid.raw", 100, 200, width, height, 3);
    Run_Slic(filename, "Rhinos_200_200_grid.raw", 200, 200, width, height, 3);
    Run_Slic(filename, "Rhinos_300_200_grid.raw", 300, 200, width, height, 3);
    Run_Slic(filename, "Rhinos_400_200_grid.raw", 400, 200, width, height, 3);


    // test parameter: spatial radius
    /*Run_MeanShift("Rhinos_100_10.raw", "MS_Rhinos_100_10_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_200_10.raw", "MS_Rhinos_200_10_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_10.raw", "MS_Rhinos_300_10_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_400_10.raw", "MS_Rhinos_400_10_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_100_50.raw", "MS_Rhinos_100_50_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_400_50.raw", "MS_Rhinos_400_50_4_65.raw", 4, 6.5, width, height, 3);

    Run_MeanShift("Rhinos_100_10.raw", "MS_Rhinos_100_10_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_200_10.raw", "MS_Rhinos_200_10_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_10.raw", "MS_Rhinos_300_10_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_400_10.raw", "MS_Rhinos_400_10_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_100_50.raw", "MS_Rhinos_100_50_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_400_50.raw", "MS_Rhinos_400_50_10_65.raw", 10, 6.5, width, height, 3);

    Run_MeanShift("Rhinos_100_10.raw", "MS_Rhinos_100_10_14_65.raw", 14, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_200_10.raw", "MS_Rhinos_200_10_14_65.raw", 14, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_10.raw", "MS_Rhinos_300_10_14_65.raw", 14, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_400_10.raw", "MS_Rhinos_400_10_14_65.raw", 14, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_100_50.raw", "MS_Rhinos_100_50_14_65.raw", 14, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_14_65.raw", 14, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_14_65.raw", 14, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_400_50.raw", "MS_Rhinos_400_50_14_65.raw", 14, 6.5, width, height, 3);*/

    // test parameter: color radius
    /*Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_4_2.raw", 4, 2, width, height, 3);
    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_10_2.raw", 10, 2, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_4_2.raw", 4, 2, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_10_2.raw", 10, 2, width, height, 3);

    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_10_65.raw", 10, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_4_65.raw", 4, 6.5, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_10_65.raw", 10, 6.5, width, height, 3);

    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_4_12.raw", 4, 12, width, height, 3);
    Run_MeanShift("Rhinos_200_50.raw", "MS_Rhinos_200_50_10_12.raw", 10, 12, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_4_12.raw", 4, 12, width, height, 3);
    Run_MeanShift("Rhinos_300_50.raw", "MS_Rhinos_300_50_10_12.raw", 10, 12, width, height, 3);*/

}

void p3a1() {
    string filename = FOLDER + LABLE1 + ".raw";

    // test parameter: superpixel
    Run_Slic(filename, "Man_100_10._grid.raw", 100, 10, 481, 321, 3);
    Run_Slic(filename, "Man_200_10._grid.raw", 200, 10, 481, 321, 3);
    Run_Slic(filename, "Man_300_10._grid.raw", 300, 10, 481, 321, 3);
    Run_Slic(filename, "Man_400_10._grid.raw", 400, 10, 481, 321, 3);
    Run_Slic(filename, "Man_100_50._grid.raw", 100, 50, 481, 321, 3);
    Run_Slic(filename, "Man_200_50._grid.raw", 200, 50, 481, 321, 3);
    Run_Slic(filename, "Man_300_50._grid.raw", 300, 50, 481, 321, 3);
    Run_Slic(filename, "Man_400_50._grid.raw", 400, 50, 481, 321, 3);
    Run_Slic(filename, "Man_100_100._grid.raw", 100, 100, 481, 321, 3);
    Run_Slic(filename, "Man_200_100._grid.raw", 200, 100, 481, 321, 3);
    Run_Slic(filename, "Man_300_100._grid.raw", 300, 100, 481, 321, 3);
    Run_Slic(filename, "Man_400_100._grid.raw", 400, 100, 481, 321, 3);
    Run_Slic(filename, "Man_100_200._grid.raw", 100, 200, 481, 321, 3);
    Run_Slic(filename, "Man_200_200._grid.raw", 200, 200, 481, 321, 3);
    Run_Slic(filename, "Man_300_200._grid.raw", 300, 200, 481, 321, 3);
    Run_Slic(filename, "Man_400_200._grid.raw", 400, 200, 481, 321, 3);


    // test parameter: spatial radius
    /*Run_MeanShift("Man_100_10.raw", "MS_Man_100_10_4_65.raw", 4, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_10.raw", "MS_Man_200_10_4_65.raw", 4, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_10.raw", "MS_Man_300_10_4_65.raw", 4, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_10.raw", "MS_Man_400_10_4_65.raw", 4, 6.5, 481, 321, 3);
    Run_MeanShift("Man_100_50.raw", "MS_Man_100_50_4_65.raw", 4, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_50.raw", "MS_Man_200_50_4_65.raw", 4, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_50.raw", "MS_Man_300_50_4_65.raw", 4, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_50.raw", "MS_Man_400_50_4_65.raw", 4, 6.5, 481, 321, 3);*/

    /*Run_MeanShift("Man_100_10.raw", "MS_Man_100_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_10.raw", "MS_Man_200_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_10.raw", "MS_Man_300_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_10.raw", "MS_Man_400_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_100_50.raw", "MS_Man_100_50_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_50.raw", "MS_Man_200_50_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_50.raw", "MS_Man_300_50_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_50.raw", "MS_Man_400_50_10_65.raw", 10, 6.5, 481, 321, 3);*/

    /*Run_MeanShift("Man_100_10.raw", "MS_Man_100_10_14_65.raw", 14, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_10.raw", "MS_Man_200_10_14_65.raw", 14, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_10.raw", "MS_Man_300_10_14_65.raw", 14, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_10.raw", "MS_Man_400_10_14_65.raw", 14, 6.5, 481, 321, 3);
    Run_MeanShift("Man_100_50.raw", "MS_Man_100_50_14_65.raw", 14, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_50.raw", "MS_Man_200_50_14_65.raw", 14, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_50.raw", "MS_Man_300_50_14_65.raw", 14, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_50.raw", "MS_Man_400_50_14_65.raw", 14, 6.5, 481, 321, 3);*/

    // test parameter: color radius
    /*Run_MeanShift("Man_100_10.raw", "MS_Man_100_10_10_2.raw", 10, 2, 481, 321, 3);
    Run_MeanShift("Man_200_10.raw", "MS_Man_200_10_10_2.raw", 10, 2, 481, 321, 3);
    Run_MeanShift("Man_300_10.raw", "MS_Man_300_10_10_2.raw", 10, 2, 481, 321, 3);
    Run_MeanShift("Man_400_10.raw", "MS_Man_400_10_10_2.raw", 10, 2, 481, 321, 3);
    Run_MeanShift("Man_100_50.raw", "MS_Man_100_50_10_2.raw", 10, 2, 481, 321, 3);
    Run_MeanShift("Man_200_50.raw", "MS_Man_200_50_10_2.raw", 10, 2, 481, 321, 3);
    Run_MeanShift("Man_300_50.raw", "MS_Man_300_50_10_2.raw", 10, 2, 481, 321, 3);
    Run_MeanShift("Man_400_50.raw", "MS_Man_400_50_10_2.raw", 10, 2, 481, 321, 3);*/

    /*Run_MeanShift("Man_100_10.raw", "MS_Man_100_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_10.raw", "MS_Man_200_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_10.raw", "MS_Man_300_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_10.raw", "MS_Man_400_10_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_100_50.raw", "MS_Man_100_50_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_200_50.raw", "MS_Man_200_50_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_300_50.raw", "MS_Man_300_50_10_65.raw", 10, 6.5, 481, 321, 3);
    Run_MeanShift("Man_400_50.raw", "MS_Man_400_50_10_65.raw", 10, 6.5, 481, 321, 3);*/

    /*Run_MeanShift("Man_100_10.raw", "MS_Man_100_10_10_12.raw", 10, 12, 481, 321, 3);
    Run_MeanShift("Man_200_10.raw", "MS_Man_200_10_10_12.raw", 10, 12, 481, 321, 3);
    Run_MeanShift("Man_300_10.raw", "MS_Man_300_10_10_12.raw", 10, 12, 481, 321, 3);
    Run_MeanShift("Man_400_10.raw", "MS_Man_400_10_10_12.raw", 10, 12, 481, 321, 3);
    Run_MeanShift("Man_100_50.raw", "MS_Man_100_50_10_12.raw", 10, 12, 481, 321, 3);
    Run_MeanShift("Man_200_50.raw", "MS_Man_200_50_10_12.raw", 10, 12, 481, 321, 3);
    Run_MeanShift("Man_300_50.raw", "MS_Man_300_50_10_12.raw", 10, 12, 481, 321, 3);
    Run_MeanShift("Man_400_50.raw", "MS_Man_400_50_10_12.raw", 10, 12, 481, 321, 3);*/

}


int main(int argc, char *argv[]) {
    p3a1();
    p3a2();

  return 0;
}
/* EE569 Homework Assignment #2
 * Date: October 14, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Image Segmentation
 *
 * Main function:
 * p2_main.cpp
 *
 * Class slic:
 * slic.h
 * slic.cpp
 *
 * Function Meanshift
 * meanshift.h
 * meanshift.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * MATLAB code
 * p3b.m
 * p3c.m
 * run_cpp.m
 * run_evaluation.m
 */
/* slic.h.
 *
 * Written by: Pascal Mettes.
 *
 * This file contains the class elements of the class Slic. This class is an
 * implementation of the SLIC Superpixel algorithm by Achanta et al. [PAMI'12,
 * vol. 34, num. 11, pp. 2274-2282].
 *
 * This implementation is created for the specific purpose of creating
 * over-segmentations in an OpenCV-based environment.
 * From: https://github.com/PSMM/SLIC-Superpixels
 */

/* meanshift.h
 * Author: Kanglai Qian
 * From: https://github.com/qiankanglai/opencv.meanshift
*/

#include "slic.h"

/*
 * Constructor. Nothing is done here.
 */
Slic::Slic() {

}

/*
 * Destructor. Clear any present data.
 */
Slic::~Slic() {
    clear_data();
}

/*
 * Clear the data as saved by the algorithm.
 *
 * Input : -
 * Output: -
 */
void Slic::clear_data() {
    clusters.clear();
    distances.clear();
    centers.clear();
    center_counts.clear();
}

/*
 * Initialize the cluster centers and initial values of the pixel-wise cluster
 * assignment and distance values.
 *
 * Input : The image (IplImage*).
 * Output: -
 */
void Slic::init_data(IplImage *image) {
    /* Initialize the cluster and distance matrices. */
    for (int i = 0; i < image->width; i++) { 
        vector<int> cr;
        vector<double> dr;
        for (int j = 0; j < image->height; j++) {
            cr.push_back(-1);
            dr.push_back(FLT_MAX);
        }
        clusters.push_back(cr);
        distances.push_back(dr);
    }
    
    /* Initialize the centers and counters. */
    for (int i = step; i < image->width - step/2; i += step) {
        for (int j = step; j < image->height - step/2; j += step) {
            vector<double> center;
            /* Find the local minimum (gradient-wise). */
            CvPoint nc = find_local_minimum(image, cvPoint(i,j));
            CvScalar colour = cvGet2D(image, nc.y, nc.x);
            
            /* Generate the center vector. */
            center.push_back(colour.val[0]);
            center.push_back(colour.val[1]);
            center.push_back(colour.val[2]);
            center.push_back(nc.x);
            center.push_back(nc.y);
            
            /* Append to vector of centers. */
            centers.push_back(center);
            center_counts.push_back(0);
        }
    }
}

/*
 * Compute the distance between a cluster center and an individual pixel.
 *
 * Input : The cluster index (int), the pixel (CvPoint), and the Lab values of
 *         the pixel (CvScalar).
 * Output: The distance (double).
 */
double Slic::compute_dist(int ci, CvPoint pixel, CvScalar colour) {
    double dc = sqrt(pow(centers[ci][0] - colour.val[0], 2) + pow(centers[ci][1]
            - colour.val[1], 2) + pow(centers[ci][2] - colour.val[2], 2));
    double ds = sqrt(pow(centers[ci][3] - pixel.x, 2) + pow(centers[ci][4] - pixel.y, 2));
    
    return sqrt(pow(dc / nc, 2) + pow(ds / ns, 2));
    
    //double w = 1.0 / (pow(ns / nc, 2));
    //return sqrt(dc) + sqrt(ds * w);
}

/*
 * Find a local gradient minimum of a pixel in a 3x3 neighbourhood. This
 * method is called upon initialization of the cluster centers.
 *
 * Input : The image (IplImage*) and the pixel center (CvPoint).
 * Output: The local gradient minimum (CvPoint).
 */
CvPoint Slic::find_local_minimum(IplImage *image, CvPoint center) {
    double min_grad = FLT_MAX;
    CvPoint loc_min = cvPoint(center.x, center.y);
    
    for (int i = center.x-1; i < center.x+2; i++) {
        for (int j = center.y-1; j < center.y+2; j++) {
            CvScalar c1 = cvGet2D(image, j+1, i);
            CvScalar c2 = cvGet2D(image, j, i+1);
            CvScalar c3 = cvGet2D(image, j, i);
            /* Convert colour values to grayscale values. */
            double i1 = c1.val[0];
            double i2 = c2.val[0];
            double i3 = c3.val[0];
            /*double i1 = c1.val[0] * 0.11 + c1.val[1] * 0.59 + c1.val[2] * 0.3;
            double i2 = c2.val[0] * 0.11 + c2.val[1] * 0.59 + c2.val[2] * 0.3;
            double i3 = c3.val[0] * 0.11 + c3.val[1] * 0.59 + c3.val[2] * 0.3;*/
            
            /* Compute horizontal and vertical gradients and keep track of the
               minimum. */
            if (sqrt(pow(i1 - i3, 2)) + sqrt(pow(i2 - i3,2)) < min_grad) {
                min_grad = fabs(i1 - i3) + fabs(i2 - i3);
                loc_min.x = i;
                loc_min.y = j;
            }
        }
    }
    
    return loc_min;
}

/*
 * Compute the over-segmentation based on the step-size and relative weighting
 * of the pixel and colour values.
 *
 * Input : The Lab image (IplImage*), the stepsize (int), and the weight (int).
 * Output: -
 */
void Slic::generate_superpixels(IplImage *image, int step, int nc) {
    this->step = step;
    this->nc = nc;
    this->ns = step;
    
    /* Clear previous data (if any), and re-initialize it. */
    clear_data();
    init_data(image);
    
    /* Run EM for 10 iterations (as prescribed by the algorithm). */
    for (int i = 0; i < NR_ITERATIONS; i++) {
        /* Reset distance values. */
        for (int j = 0; j < image->width; j++) {
            for (int k = 0;k < image->height; k++) {
                distances[j][k] = FLT_MAX;
            }
        }

        for (int j = 0; j < (int) centers.size(); j++) {
            /* Only compare to pixels in a 2 x step by 2 x step region. */
            for (int k = centers[j][3] - step; k < centers[j][3] + step; k++) {
                for (int l = centers[j][4] - step; l < centers[j][4] + step; l++) {
                
                    if (k >= 0 && k < image->width && l >= 0 && l < image->height) {
                        CvScalar colour = cvGet2D(image, l, k);
                        double d = compute_dist(j, cvPoint(k,l), colour);
                        
                        /* Update cluster allocation if the cluster minimizes the
                           distance. */
                        if (d < distances[k][l]) {
                            distances[k][l] = d;
                            clusters[k][l] = j;
                        }
                    }
                }
            }
        }
        
        /* Clear the center values. */
        for (int j = 0; j < (int) centers.size(); j++) {
            centers[j][0] = centers[j][1] = centers[j][2] = centers[j][3] = centers[j][4] = 0;
            center_counts[j] = 0;
        }
        
        /* Compute the new cluster centers. */
        for (int j = 0; j < image->width; j++) {
            for (int k = 0; k < image->height; k++) {
                int c_id = clusters[j][k];
                
                if (c_id != -1) {
                    CvScalar colour = cvGet2D(image, k, j);
                    
                    centers[c_id][0] += colour.val[0];
                    centers[c_id][1] += colour.val[1];
                    centers[c_id][2] += colour.val[2];
                    centers[c_id][3] += j;
                    centers[c_id][4] += k;
                    
                    center_counts[c_id] += 1;
                }
            }
        }

        /* Normalize the clusters. */
        for (int j = 0; j < (int) centers.size(); j++) {
            centers[j][0] /= center_counts[j];
            centers[j][1] /= center_counts[j];
            centers[j][2] /= center_counts[j];
            centers[j][3] /= center_counts[j];
            centers[j][4] /= center_counts[j];
        }
    }
}

/*
 * Enforce connectivity of the superpixels. This part is not actively discussed
 * in the paper, but forms an active part of the implementation of the authors
 * of the paper.
 *
 * Input : The image (IplImage*).
 * Output: -
 */
void Slic::create_connectivity(IplImage *image) {
    int label = 0, adjlabel = 0;
    const int lims = (image->width * image->height) / ((int)centers.size());
    
    const int dx4[4] = {-1,  0,  1,  0};
	const int dy4[4] = { 0, -1,  0,  1};
    
    /* Initialize the new cluster matrix. */
    vec2di new_clusters;
    for (int i = 0; i < image->width; i++) { 
        vector<int> nc;
        for (int j = 0; j < image->height; j++) {
            nc.push_back(-1);
        }
        new_clusters.push_back(nc);
    }

    for (int i = 0; i < image->width; i++) {
        for (int j = 0; j < image->height; j++) {
            if (new_clusters[i][j] == -1) {
                vector<CvPoint> elements;
                elements.push_back(cvPoint(i, j));
            
                /* Find an adjacent label, for possible use later. */
                for (int k = 0; k < 4; k++) {
                    int x = elements[0].x + dx4[k], y = elements[0].y + dy4[k];
                    
                    if (x >= 0 && x < image->width && y >= 0 && y < image->height) {
                        if (new_clusters[x][y] >= 0) {
                            adjlabel = new_clusters[x][y];
                        }
                    }
                }
                
                int count = 1;
                for (int c = 0; c < count; c++) {
                    for (int k = 0; k < 4; k++) {
                        int x = elements[c].x + dx4[k], y = elements[c].y + dy4[k];
                        
                        if (x >= 0 && x < image->width && y >= 0 && y < image->height) {
                            if (new_clusters[x][y] == -1 && clusters[i][j] == clusters[x][y]) {
                                elements.push_back(cvPoint(x, y));
                                new_clusters[x][y] = label;
                                count += 1;
                            }
                        }
                    }
                }
                
                /* Use the earlier found adjacent label if a segment size is
                   smaller than a limit. */
                if (count <= lims >> 2) {
                    for (int c = 0; c < count; c++) {
                        new_clusters[elements[c].x][elements[c].y] = adjlabel;
                    }
                    label -= 1;
                }
                label += 1;
            }
        }
    }
}

/*
 * Display the cluster centers.
 *
 * Input : The image to display upon (IplImage*) and the colour (CvScalar).
 * Output: -
 */
void Slic::display_center_grid(IplImage *image, CvScalar colour) {
    for (int i = 0; i < (int) centers.size(); i++) {
        cvCircle(image, cvPoint(centers[i][3], centers[i][4]), 2, colour, 2);
    }
}

/*
 * Display a single pixel wide contour around the clusters.
 *
 * Input : The target image (IplImage*) and contour colour (CvScalar).
 * Output: -
 */
void Slic::display_contours(IplImage *image, CvScalar colour) {
    const int dx8[8] = {-1, -1,  0,  1, 1, 1, 0, -1};
	const int dy8[8] = { 0, -1, -1, -1, 0, 1, 1,  1};
	
	/* Initialize the contour vector and the matrix detailing whether a pixel
	 * is already taken to be a contour. */
	vector<CvPoint> contours;
	vec2db istaken;
	for (int i = 0; i < image->width; i++) { 
        vector<bool> nb;
        for (int j = 0; j < image->height; j++) {
            nb.push_back(false);
        }
        istaken.push_back(nb);
    }
    
    /* Go through all the pixels. */
    for (int i = 0; i < image->width; i++) {
        for (int j = 0; j < image->height; j++) {
            int nr_p = 0;
            
            /* Compare the pixel to its 8 neighbours. */
            for (int k = 0; k < 8; k++) {
                int x = i + dx8[k], y = j + dy8[k];
                
                if (x >= 0 && x < image->width && y >= 0 && y < image->height) {
                    if (istaken[x][y] == false && clusters[i][j] != clusters[x][y]) {
                        nr_p += 1;
                    }
                }
            }
            
            /* Add the pixel to the contour list if desired. */
            if (nr_p >= 2) {
                contours.push_back(cvPoint(i,j));
                istaken[i][j] = true;
            }
        }
    }
    
    /* Draw the contour pixels. */
    for (int i = 0; i < (int)contours.size(); i++) {
        cvSet2D(image, contours[i].y, contours[i].x, colour);
    }
}

/*
 * Give the pixels of each cluster the same colour values. The specified colour
 * is the mean RGB colour per cluster.
 *
 * Input : The target image (IplImage*).
 * Output: -
 */
void Slic::colour_with_cluster_means(IplImage *image) {
    vector<CvScalar> colours(centers.size());
    
    /* Gather the colour values per cluster. */
    for (int i = 0; i < image->width; i++) {
        for (int j = 0; j < image->height; j++) {
            int index = clusters[i][j];
            CvScalar colour = cvGet2D(image, j, i);
            
            colours[index].val[0] += colour.val[0];
            colours[index].val[1] += colour.val[1];
            colours[index].val[2] += colour.val[2];
        }
    }
    
    /* Divide by the number of pixels per cluster to get the mean colour. */
    for (int i = 0; i < (int)colours.size(); i++) {
        colours[i].val[0] /= center_counts[i];
        colours[i].val[1] /= center_counts[i];
        colours[i].val[2] /= center_counts[i];
    }
    
    /* Fill in. */
    for (int i = 0; i < image->width; i++) {
        for (int j = 0; j < image->height; j++) {
            CvScalar ncolour = colours[clusters[i][j]];
            cvSet2D(image, j, i, ncolour);
        }
    }
}
/* EE569 Homework Assignment #2
 * Date: October 14, 2015
 * Name: Meiyi Yang
 * ID: 6761054585
 * email: meiyiyan@usc.edu
 * Problem2. Image Segmentation
 *
 * Main function:
 * p2_main.cpp
 *
 * Class slic:
 * slic.h
 * slic.cpp
 *
 * Function Meanshift
 * meanshift.h
 * meanshift.cpp
 *
 * Class ImgMatOperator (General class for whole HW2)
 * hw2_helper.h
 * hw2_helper.cpp
 *
 * MATLAB code
 * p3b.m
 * p3c.m
 * run_cpp.m
 * run_evaluation.m
 */
/* slic.h.
 *
 * Written by: Pascal Mettes.
 *
 * This file contains the class elements of the class Slic. This class is an
 * implementation of the SLIC Superpixel algorithm by Achanta et al. [PAMI'12,
 * vol. 34, num. 11, pp. 2274-2282].
 *
 * This implementation is created for the specific purpose of creating
 * over-segmentations in an OpenCV-based environment.
 * From: https://github.com/PSMM/SLIC-Superpixels
 */

/* meanshift.h
 * Author: Kanglai Qian
 * From: https://github.com/qiankanglai/opencv.meanshift
*/

#ifndef SLIC_H
#define SLIC_H

#include <opencv/cv.h>
#include <opencv/highgui.h>
#include <stdio.h>
#include <math.h>
#include <vector>
#include <float.h>
using namespace std;

/* 2d matrices are handled by 2d vectors. */
#define vec2dd vector<vector<double> >
#define vec2di vector<vector<int> >
#define vec2db vector<vector<bool> >
/* The number of iterations run by the clustering algorithm. */
#define NR_ITERATIONS 10

/*
 * class Slic.
 *
 * In this class, an over-segmentation is created of an image, provided by the
 * step-size (distance between initial cluster locations) and the colour
 * distance parameter.
 */
class Slic {
    private:
        /* The cluster assignments and distance values for each pixel. */
        vec2di clusters;
        vec2dd distances;
        
        /* The LAB and xy values of the centers. */
        vec2dd centers;
        /* The number of occurences of each center. */
        vector<int> center_counts;
        
        /* The step size per cluster, and the colour (nc) and distance (ns)
         * parameters. */
        int step, nc, ns;
        
        /* Compute the distance between a center and an individual pixel. */
        double compute_dist(int ci, CvPoint pixel, CvScalar colour);
        /* Find the pixel with the lowest gradient in a 3x3 surrounding. */
        CvPoint find_local_minimum(IplImage *image, CvPoint center);
        
        /* Remove and initialize the 2d vectors. */
        void clear_data();
        void init_data(IplImage *image);

    public:
        /* Class constructors and deconstructors. */
        Slic();
        ~Slic();
        
        /* Generate an over-segmentation for an image. */
        void generate_superpixels(IplImage *image, int step, int nc);
        /* Enforce connectivity for an image. */
        void create_connectivity(IplImage *image);
        
        /* Draw functions. Resp. displayal of the centers and the contours. */
        void display_center_grid(IplImage *image, CvScalar colour);
        void display_contours(IplImage *image, CvScalar colour);
        void colour_with_cluster_means(IplImage *image);
};

#endif
% EE569 Homework Assignment #2 
% Date: October. 11th 2015 
% Name: Meiyi Yang
% ID:  6761-0405-85 
% email:  meiyiyan@usc.edu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 3: Image Segmentation
% (b) Color Palettes Generation
% M-file list:   p3b.m
%                run_cpp.m
% Usage:         run p3b.m
% Function usage: run_cpp(filename, row, col)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
clear all;
clc;

[bound_segment, color_segment] = run_cpp('Man.raw', 481, 321);
save Man.mat bound_segment color_segment;
[bound_segment, color_segment] = run_cpp('Rhinos.raw', 321, 481);
save Rhinos.mat bound_segment color_segment;
% EE569 Homework Assignment #2 
% Date: October. 11th 2015 
% Name: Meiyi Yang
% ID:  6761-0405-85 
% email:  meiyiyan@usc.edu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 3: Image Segmentation
% (c) Segmentation Result Evaluation
% M-file list:   p3c.m
%                run_evaluation.m
% Usage:         run p3c.m
% Function usage: run_evaluation(segmentation_data, groundtrue_data, row, col, FLAGl)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
clear all;
[curCOV, curPRI,curGCE,curVOI, curBDE] = run_evaluation('Man.mat', 'Man_bound_GT.raw', 481, 321, 1);
[curCOV, curPRI,curGCE,curVOI, curBDE]
[curCOV, curPRI,curGCE,curVOI, curBDE] = run_evaluation('Man.mat', 'Man_color_GT.raw', 481, 321, 2);
[curCOV, curPRI,curGCE,curVOI, curBDE]
[curCOV, curPRI,curGCE,curVOI, curBDE] = run_evaluation('Rhinos.mat', 'Rhinos_bound_GT.raw', 321, 481, 1);
[curCOV, curPRI,curGCE,curVOI, curBDE]
[curCOV, curPRI,curGCE,curVOI, curBDE] = run_evaluation('Rhinos.mat', 'Rhinos_color_GT.raw', 321, 481, 2);
[curCOV, curPRI,curGCE,curVOI, curBDE]
% EE569 Homework Assignment #2 
% Date: October. 11th 2015 
% Name: Meiyi Yang
% ID:  6761-0405-85 
% email:  meiyiyan@usc.edu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 3: Image Segmentation
% (b) Color Palettes Generation
% M-file list:   p3b.m
%                run_cpp.m
% Usage:         run p3b.m
% Function usage: run_cpp(filename, row, col)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% @para
% filename: read the original image
% row: this image's row
% column: this image's column
% filename_write: write bound, color segment result to filename_write
%%
% This code is to implement contour-guided color palette segmentation method described in:
% "Robust Image Segmentation Using Contour-guided Color Palettes" 
% by Xiang Fu, Chien-Yi Wang, Chen Chen, Changhu Wang, and C.-C. Jay Kuo. ICCV 2015
% {xiangfu, chienyiw, chen80}@usc.edu, chw@microsoft.com, cckuo@sipi.usc.edu
%
% Please contact the corresponding author if you have any questions.
% Xiang Fu: xiangfu AT usc DOT edu or fuxiang87 AT gmail DOT com

function [bound_segment, color_segment] = run_cpp(filename, row, col)
%% parameter setting
% parameters for downscaling
scale   = 1.0;      % downscale

% parameters for bilateral filter (denoising)
w       = 5;        % half-width
sigma_c = 5;        % standard deviations of color
sigma_s = 5;        % standard deviations of space

% parameters for edge detection
extRange = 4;       % edge extension to improve edge detection
lengthTH = 10;      % length above this number is long ontour

% parameters for mean shift (KEY parameter)
msradius = 5;       % spectral radius for mean shift on sampled color space

% parameters for region cleaning
areaTH.large = 500; % area above this number is large region
areaTH.small = 200; % area blow this number is small region

%% read color image
byte = 3;
fin = fopen(filename, 'r');
I_temp = fread(fin, row * col * byte, 'uchar');
I_temp = uint8(I_temp);
I_ori = ones(row, col, byte);
count = 0;
for i = 1:row
    for j = 1:col
        for k = 1:byte
            count = count + 1;
            I_ori(i, j, k) = I_temp(count, 1);
        end;
    end;
end;
%I = uint8(I);
fclose(fin);
I_ori = uint8(I_ori);
ori_img  = I_ori;
ori_img = imresize(ori_img, scale); % scale the image
[H,W,C] = size(ori_img);
figure, imshow(ori_img);

%% image denoising (shiftableBF for O(1) version)
lab_img = colorspace('Lab<-', ori_img);
Lcolumn = lab_img(:,:,1); % [  0 - 100]
Acolumn = lab_img(:,:,2); % [-50 -  50]
Bcolumn = lab_img(:,:,3); % [-50 -  50]
%Lcolumn = bilateral_filter(Lcolumn,w,sigma_c,sigma_s);
Lcolumn = shiftableBF(Lcolumn,sigma_s,sigma_c,w,0.01);
lab_denoise = cat(3,Lcolumn,Acolumn,Bcolumn);
lab_data = reshape(lab_denoise,H*W,C);
rgb_denoise = colorspace('RGB<-Lab', lab_denoise);   
figure, imshow(rgb_denoise)

%% structured edge detection
%Need Piotr's Computer Vision Matlab Toolbox
setParametersSED;
edge_map = edgesDetect(ori_img,model);
figure, imshow(1-edge_map);
% edge extension
bin_edge_map = edgeExtension(edge_map>0.1, extRange);
[edgelist, labelededgeim] = edgelink(bin_edge_map, lengthTH);

%% Contour-guided Color Palette
% Color Palette Generation
tic;
[long_conts_map,sampledColor] = findSampledColor(lab_denoise, edgelist, lengthTH);
t1 = toc;
figure, imshow(1-long_conts_map);

colorPalette = MeanShiftCluster(sampledColor', msradius)';
% quantized image
Dist = zeros(H*W,size(colorPalette,1));
for i = 1:size(colorPalette,1)
    Dist(:,i) = sum((lab_data - colorPalette(repmat(i,H*W,1),:)).^2, 2);
end
[~, labels] = min(Dist, [], 2);
[~, color_segment] = display_color_seg(im2double(ori_img), labels);
figure, imshow(color_segment);
tic;
% Post-Processing
label_map = reshape(labels,H,W);%cleanupregions(reshape(labels,H,W), 0, 4);
[newlabel_map,seg_obj] = aggreg_regions(label_map, rgb_denoise, long_conts_map, lab_data, areaTH);
[bound_segment, color_segment] = display_color_seg(im2double(ori_img), newlabel_map(:));
figure, imshow(color_segment);
t2 = toc;
% EE569 Homework Assignment #2 
% Date: October. 11th 2015 
% Name: Meiyi Yang
% ID:  6761-0405-85 
% email:  meiyiyan@usc.edu
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Problem 3: Image Segmentation
% (c) Segmentation Result Evaluation
% M-file list:   p3c.m
%                run_evaluation.m
% Usage:         run p3c.m
% Function usage: run_evaluation(segmentation_data, groundtrue_data, row, col, FLAGl)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 

%% parameter
% segmentation_data: be evaluated data(.mat): save in p3b, include
% color_segment, bound segment
% groundtrue_data: ground true raw image
% row: row of ground true image
% col: column of ground true image
% FLAG: 1 is for boundary evaluation, 2 is for color evaluation
%%
%A MATLAB Toolbox
%
%Compare segmentation results with the Berkeley benchmark using four indices
%1. Probabilistic Rand Index
%2. Variation of Information
%3. Global Consistency Error
%4. Boundary Displacement Error
%
%The first three measures are calculated by the function compare_segmentations.m
%The last boundary measure is calculated by compare_image_boundary_error.m
%
%Please notice that this batch file is written to specifically compare the
%lossy coding results with the human segmentations in the Berkeley segbench database.
%
%As a result, the segbench human prior is resized to match the testset results.
%
%Authors: John Wright, and Allen Y. Yang
%Contact: Allen Y. Yang <yang@eecs.berkeley.edu>
%
%(c) Copyright. University of California, Berkeley. 2007.
%
%Notice: The packages should NOT be used for any commercial purposes
%without direct consent of their author(s). The authors are not responsible for any potential property loss or damage caused directly or indirectly by the usage of the software.
 
function [curCOV, curPRI,curGCE,curVOI, curBDE] = run_evaluation(segmentation_data, groundtrue_data, row, col, FLAG)
%% load segmentation data
load(segmentation_data);
%% read ground true
byte = 3;
fin = fopen(groundtrue_data, 'r');
I_read = fread(fin, row * col * byte, 'uchar');
I_read = uint8(I_read);
I = ones(row, col, byte);
count = 0;
for i = 1:row
    for j = 1:col
        for k = 1:byte
            count = count + 1;
            I(i, j, k) = I_read(count, 1);
        end;
    end;
end;
I = double(I);
fclose(fin);
%% read evaluated data and convert GT
benchLabels = ones(row, col);
for i = 1: row
    for j = 1: col
      for k = 1:3
          if (FLAG == 1)
            benchLabels(i, (j - 1) * 3 + k) = 255 * bound_segment(i, j, k);
          else
              benchLabels(i, (j - 1) * 3 + k) = 255 * color_segment(i, j, k);
          end
      end
    end
end
sampleLabels = ones(row, col);
for i = 1: row
    for j = 1: col
       for k = 1:3
          sampleLabels(i, (j - 1) * 3 + k) = I(i, j, k);
      end
    end
end
benchLabels = uint8(benchLabels);
sampleLabels = uint8(sampleLabels);
benchLabels = double(benchLabels);
sampleLabels = double(sampleLabels);
figure, imshow(benchLabels);
figure, imshow(sampleLabels);
%% Begin evaluation
% update the four error measures:        
curBDE = compare_image_boundary_error(benchLabels, sampleLabels);     
[curPRI,curGCE,curVOI] = compare_segmentations(sampleLabels,benchLabels); 
% update cov
groundTruth{1}.Segmentation = sampleLabels;
seg = benchLabels;
[curCOV] = compare_covering(seg,groundTruth);




